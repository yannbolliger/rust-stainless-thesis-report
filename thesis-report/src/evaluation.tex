This chapter presents how Rust-Stainless is tested and gives some examples of
code that the tool can verify. Furthermore, it will decompose the running time
of a typical execution into its subparts and finish by presenting a
blockchain-related code example implemented by Informal Systems and verified
with Rust-Stainless.

\section{Benchmarks}

The Rust-Stainless repository contains a test suite of 65 passing (positive) and
12 failing (negative) test code examples of in total around 3000
lines.\footnote{Found under \texttt{stainless\_frontend/tests/[pass|fail]} on
the \texttt{mutable-cells} branch.} The suite is run for every pull request and
every commit to the \texttt{master} branch.

To quantitatively evaluate Rust-Stainless, I collected some statistics of all
the positive test examples, displayed in \autoref{measurements}.\footnote{All
the tests were run on a MacBook Pro with a 2.8~GHz Quad-Core Intel Core i7 and
16~GB of RAM.} Only the positive examples were used for the measurements because
the negative examples may fail at different stages of the extraction or
verification pipeline. Thus, the time measurement is only representative for the
positive examples which complete the verification pipeline. The used benchmarks
amount to 2100 lines of Rust code (LoC), Stainless generates in total 470
verification conditions (VCs) and the accumulated running time is just under 6
minutes (Total). Note that the test suite normally (when run with \texttt{cargo
test}) runs multiple tests in parallel and thus completes in less than 2 minutes
on the same machine.

It is instructive to decompose the running time of the test examples into the
different parts of the pipeline. As described in
\autoref{sec:extraction-overview}, the frontend first needs to detect some
standard library items before it can translate the user crate. Even if the
detection iterates through the same crates on each run, one observes larger
variations in its running time. On average, detection takes $199 \pm 33$~ms or
equivalently 4~\% of the running time.

The actual translation is very fast, especially for the rather short examples
that account for the majority of the test suite. It takes only 0.4~ms or about
0.008~\% of the running time on average. By far the largest part of the running
time of our tool is not spent in the frontend itself but rather in the JVM
backend that performs verification. Verification time accounts for on average
95~\% of the total running time. The rest of the time is made up of starting,
serialising and reporting. This shows that translation time is inferior to
verification time by 1-2 orders of magnitudes which is not surprising, given
that verification is much more complex than the translation.

\input{measurements/measurements.tex}


\section{Code Examples}

After having quantitatively measured our tool, it is time to qualitatively
evaluate what it is capable of and to that end present some code examples. The
first three examples stem from the test suite of Rust-Stainless and are included
in the measurements from above. The fourth example is the running example from
\autoref{background} and the last one is an implementation by Informal Systems
used in the IBC implementation.

\subsection{Test Suite Examples}

\paragraph{Insertion Sort}

The first example is \autoref{lst:insertion-sort}, an implementation of
\emph{insertion sort} on the already mentioned functional linked-list. The
recursive data type is enabled by the support for boxes. As this example was
translated from an equivalent Scala example in Stainless's test suite, it shows
a functional way of writing Rust; there is no mutation in the entire example. In
idiomatic Rust, one would probably use a vector instead of a linked-list.

The example further showcases the use of implementation blocks and specs on
methods. For proving termination of the recursive implementation it is also
crucial to add the new \lstinline!measure! attributes. Also note that the
\lstinline!Option! type is the one of the standard library.

\paragraph{Type Class}

The next example in \autoref{lst:type-class} is also completely immutable and
demonstrates the use of a trait for equality (\lstinline!Equals!) with two
implementations. Note that one would usually use the traits from the standard
library (\lstinline!Eq! and \lstinline!PartialEq!) and let the macro derive
implementations them. Here however, equality is implemented in the program
because it serves as a good example for the contract one can add on a trait. The
trait contains three laws corresponding to the three properties of the equality
relation.

The implementation for \lstinline!i32! is trivial except that it needs to
dereference the two operands. This is to force the compiler of using the
primitive comparison operator instead of  \lstinline!PartialEq::eq!. The
linked-list implementation (\autoref{lst:equals-list}) is a good example of a
trait bound (\lstinline!T: Equals!) that will be translated to an evidence
argument. The two type class method calls on line 5 will be translated with the
correct receivers.

\begin{lstlisting}[
  language=Rust,
  caption={Equality implemented for the linked-list.},
  label={lst:equals-list}
]
impl<T: Equals> Equals for List<T> {
  fn equals(&self, other: &List<T>) -> bool {
    match (self, other) {
      (List::Nil, List::Nil) => true,
      (List::Cons(x, xs), List::Cons(y, ys)) => x.equals(y) && xs.equals(ys),
      _ => false,
    }
  }
  ...
}
\end{lstlisting}

Lastly, note that the three laws need to be reimplemented in the list
implementation. This is due to Stainless not being able to recursively proof the
properties without some guidance by the programmer. However, the same is
necessary in an equivalent Scala example. Hence, this is not a limitation of the
Rust frontend but of Stainless itself. On the other hand, the law
implementations show another construct that the frontend is able to translate:
the static method calls like \lstinline!Self::law_transitive(xs, ys, zs)! are
correctly translated to calls on the right receiver instances.

\paragraph{Local Mutability}

Turning to mutability, the benchmark in \autoref{lst:local-clone} is available
on the \texttt{mutable-cells} branch. It features a struct for which the macro
derives a \lstinline!Clone! instance. In the function, the struct is created,
cloned and mutated. The assertions ensure that the cloned instance is not
changed as well by the mutation. The mutability translation  will replace the
\lstinline!clone! call with \lstinline!freshCopy!.

\begin{lstlisting}[
  float,
  language=Rust,
  caption={Local mutation and cloning of a simple struct.},
  label=lst:local-clone
]
#[derive(Clone)]
pub struct S(i32);

pub fn main() {
  let mut a = S(1);
  let b = a.clone();
  a.0 = 10;
  assert!(a.0 != b.0)
}
\end{lstlisting}


\paragraph{Mutable References}

The running example \autoref{running-example} from \autoref{background} is
equivalent to the most complicated mutability benchmark on the
\texttt{mutable-cells} branch. In particular, it shows how a mutable reference
is matched upon and then a sub-reference is returned. The sub-reference is later
used to alter the container struct. In summary, the example requires support for
mutable borrows, pattern matching on mutable references, passing mutable
references as values, and struct mutation via references.

In the translation of \lstinline!get_mut_by_id!
(\autoref{lst:mut-ref-translated}), one can observe how the optimisations of
\autoref{optimisations} apply. The \lstinline!id! argument is not wrapped in a
mutable cell because it is immutable. The pattern match binds the mutable cell
\lstinline!v! inside the tuple ADT instead of its value, such that it can later
be used to modify the original object. Furthermore, the evidence argument
responsible for the trait method is added as parameter.

\begin{lstlisting}[
  language=Scala,
  caption={Translation of the \lstinline!get_mut_by_id! method from \autoref{running-example}.},
  label={lst:mut-ref-translated}
]
def get_mut_by_id[K @mutable, V @mutable](
  self: MutCell[Container[K, V]],
  id: Long,
  ev0: Id[K] @evidence
): Option[V] = {
  self.value.pair match {
    case MutCell(Some(MutCell(Tuple2(k, v))))
      if ev0.id(k.value) == id => Some[V](v)
    case _ => None[V]()
  }
} ensuring {
  (ret: Option[V]) => is_empty[K, V](self.value) ==> ret match {
    case None() => true
    case _ => false
  }
}
\end{lstlisting}

\subsection{Peer-list Implementation}
\label{peerlist}

benchmarks of Informal

\begin{itemize}
  \item show list map \& set
  \item found problem
  \item strengthened post-conditions
\end{itemize}
