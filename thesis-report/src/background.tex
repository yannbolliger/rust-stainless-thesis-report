This chapter offers a short introduction to the Rust language as well as the
Stainless verifier. Both parts will use a running example of a Rust program to
illustrate the involved concepts. It may seem odd to introduce Stainless with
Rust  as it is built and usually used with Scala. However, thanks to
Rust-Stainless the  usage of Stainless in Rust is so similar to the usage in
Scala that it is suitable  to reuse the running Rust example. For a more
detailed introduction to Stainless in Scala please refer to
\cite{stainless-doc}.

\section{Rust Language}

Rust \cite{rust2, rust1} is a recent systems programming language, initially
developed at Mozilla with the goal of replacing C++ as primary application
language. Its most distinguishing feature is the new approach to memory
management. Traditional languages tend to either manage memory with a
\emph{garbage collector} or require the programmer to manually allocate and,
more importantly, deallocate memory. Rust deallocates memory itself without a
garbage collector by using concepts of \emph{ownership} and \emph{reference
lifetimes}. In other words, Rust provides memory management at compile-time
which results in cost-free abstractions at runtime. Additionally, Rust
guarantees memory safety properties like  the absence of \emph{dangling
pointers}, i.e. it is impossible to dereference a freed part of memory.

To live up to its promises, Rust introduces a flow-sensitive type checker, the
\emph{borrow checker}, which is a concrete implementation of ideas that have
been studied in research for years. The two main concepts are ownership
\cite{ownership-types} and \emph{borrowing} that build on the research topics of
\emph{uniqueness} \cite{alias-burying} and \emph{linearity}
\cite{Wadler90lineartypes, once-upon-a-type}. Reference lifetimes are inspired
by work on region-based memory management \cite{cyclone-region}.


\subsection{Syntax Overview}

As a start, \autoref{lst:first-ex} shows a simple function in Rust that returns
the square of the integer \lstinline!x!. Rust is statically typed, hence
parameters have annotated types, \lstinline!i32! in our case, a signed 32-bit
integer. Other integer types can be unsigned (\lstinline!u32!) or of other
bit-lengths (\lstinline!u128!). The return type of function is indicated after
the arrow, if omitted the return type defaults to \lstinline!-> ()!, the unit
type. Note also, that the expression on the single line of the function block,
or any brace-delimited block, is implicitly returned. Alternatively, one may
employ the explicit return statement to return a value from any point in a
function, like on line 4 of \autoref{lst:let}. Statements are delimited with
semi-colons and produce the unit type.

\begin{lstlisting}[style=short, language=Rust, caption={A simple Rust function.}, label=lst:first-ex]
fn square(x: i32) -> i32 { x * x }
\end{lstlisting}

\subsubsection{Variables}

To bind values, Rust offers the \lstinline!let! statement, which creates a new
variable and binds the assigned value to it. Function parameters are also
variables in Rust~\cite{rustref}. By default, variables are immutable, that is
the compiler rejects any attempt to reassign to an initialised variable. On the
other hand, Rust accepts to redeclare and thus \emph{shadow} a binding, which is
what happens on line 7 of \autoref{lst:let}.

For most let-bindings the type of the variable is inferred by the compiler and
does not have to be annotated like for function parameters. In
\autoref{lst:let}, all the types are inferred as the standard integer type
\lstinline!i32!. This even works for bindings that shadow an earlier declaration
with a different type.

\noindent\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[language=Rust, caption={A Rust function doing some arithmetics.}, label=lst:let]
fn f(z: i32) -> i32 {
  let x = z * 10;
  if x > 100 {
    return z;
  }
  let y = z * 100;
  let z = 3;
  x + y + z
}
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[language=Rust, caption={Mutable variable bindings.}, label=lst:mut-ex]
fn g(mut a: i32) -> i32 {
  let mut b = 10;
  a += b;
  b = 100;
  a * b
}
\end{lstlisting}
\end{minipage}

\subsubsection{Mutability}

As an imperative language Rust also offers mutable bindings, but each variable
has to be explicitly declared as mutable by annotating it with the
\lstinline!mut! keyword. In general, Rust is always very explicit about the
distinction between mutable and immutable variables and references.
\autoref{lst:mut-ex} has both a mutable function parameter and a mutable local
variable.

\subsubsection{Algebraic Data Types (ADT)}

Taking strong inspiration from C, user-defined data types in Rust are called
\lstinline!struct!s and \lstinline!enum!s. Structs are product types and come in
three forms: without fields like \lstinline!OnlyAMarker! in
\autoref{lst:struct-ex}, so called \emph{unit structs}, the tuple form with
numerically indexed fields, e.g. \lstinline!a.0! and the C-like structs with
field names, \lstinline!b.field!. Enumerations are sum types and can have
members that are again like structs in either unit, tuple or C-like form.
\autoref{lst:option} shows  an example from the standard library, the option
type. It also shows how a type parameter is used to create a generic
data type.

\noindent\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[language=Rust, caption={All three types of structs.}, label=lst:struct-ex]
struct OnlyAMarker;
struct A(i32, bool);
struct B {
  field: u8
}
let a = A(0, true);
let mut b = B { field: 2 };
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[
  language=Rust,
  caption={The standard option type as an example of a generic enumeration.},
  label=lst:option
]
enum Option<T> {
    None,
    Some(T),
}
let opt: Option<i32> =
  Option::Some(123);
\end{lstlisting}
\end{minipage}

Fields are not considered variables in Rust, rather they are part of their
belonging struct's variable~\cite{rustref}. Hence, fields inherit the mutability
of their struct, e.g. the only mutable field in \autoref{lst:struct-ex} is
\lstinline!b.field! because \lstinline!b! is mutable. Hence, mutability is not
part of the field type but depends on the binding of the struct's instance.

Rust also has anonymous tuples. These behave exactly like tuple structs but
don't need to be declared beforehand. One can simply instantiate tuples of any
non-negative number of types (cf. \autoref{lst:tuples}). With that, the first
part of the running example is simply a generic container struct that has an
option of a tuple (\autoref{lst:container}).

\noindent\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[language=Rust, style=short, caption={A two-tuple in Rust.}, label=lst:tuples]
let t: (i32, bool) = (123, true);
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[language=Rust, style=short, label={lst:container}, caption={The struct for the running example.}]
struct Container<K, V> {
  pair: Option<(K, V)>,
}
\end{lstlisting}
\end{minipage}

\subsubsection{Pattern Matching}

With ADTs, especially enumerations, it is natural that Rust also offers pattern
matching. \autoref{lst:match} shows how to match on the container struct from
before. Note that match arms can be further refined by \lstinline!if! guards of
any boolean expression. To simply check whether a value matches a certain shape,
one can use the \lstinline"matches!(opt, Some(_))" macro, that is expanded to a
regular pattern match returning true for the pattern  and false otherwise.

\begin{lstlisting}[language=Rust, caption={Pattern matching on a struct.}, label=lst:match]
let c = Container { pair: None };
match c {
  Container { pair: Some((k, v)) } if k == 123 => Some(v),
  _ => None,
}
\end{lstlisting}

\subsubsection{Implementations and Traits}

Adding methods to data types is done with \lstinline!impl! blocks in Rust. There
can be many such blocks for a given type. \autoref{lst:impl1} adds three methods
to the running example of the container struct. The implementation block is
generic in two type parameters, as is the struct. Note that adding methods only
for certain instantiations of the  type parameters is also possible. For
example, the first line of the block could just be \passthrough{\lstinline!impl
Container<bool, i32>!}.

The \lstinline!Self! in the return type stands for the type the implementation
block is for, in our case \lstinline!Container<K, V>!. The \lstinline!new! method is a
static method, it is not called on an instance of a container. In contrast, the
two other methods specify a receiver type as first parameter. That makes the
methods available on instances of the container, like \lstinline!c.is_empty()!.
\lstinline!&self! acts on a reference to the instance the method is called on,
the same for \lstinline!&mut self! but mutably.\footnote{More on references in
\autoref{references}.} It is also be possible to consume the instance by
specifying \lstinline!self! as receiver.

\begin{lstlisting}[language=Rust, caption={Methods for the running example}, label=lst:impl1]
impl<K, V> Container<K, V> {
  pub fn new() -> Self { Container { pair: None } }
  pub fn is_empty(&self) -> bool { matches!(self.pair, None) }
  pub fn insert(&mut self, k: K, v: V) { self.pair = Some((k, v)) }
}
\end{lstlisting}

Traits are used in Rust to specify interfaces. A trait can be implemented for
any data type with an implementation block providing the abstract methods of the
trait, as in \autoref{lst:trait-impl2}. Traits can also be used to bound type
parameters to only the types that implement a certain trait. For example, the
trait bound \lstinline!K: Id!  in \autoref{lst:mut-ref-impl} states that any
\lstinline!K! admissible to the function (or in other cases the block) needs to
implement the \lstinline!Id! trait, i.e.~\passthrough{\lstinline!impl Id for K!}
needs to be available.

\noindent\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[language=Rust, style=short, caption={Rust trait with one method.}, label=lst:trait-impl1]
trait Id {
  fn id(&self) -> usize;
}
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[
  language=Rust,
  style=short,
  caption={Non-sensical implementation of the Id trait for strings.},
  label=lst:trait-impl2
]
impl Id for String {
  fn id(&self) -> usize { 123456 }
}
\end{lstlisting}
\end{minipage}

\subsection{Owning and Referencing Data}

\subsubsection{Value Categories}

Rust, like C but unlike Java or Scala, exposes memory management to the
programmer and allows referencing data that is stack-allocated. Therefore,  one
needs to distinguish between different \emph{value categories} of an expression:

\begin{itemize}
\tightlist
\item
  \emph{lvalues} are expressions that designate memory locations, for
  example variables, array elements etc. They are objects that have a
  storage address. The term originates from the fact that lvalues are on
  the left-hand side of an assignment.
\item
  \emph{rvalues} are expressions or temporary values that do not
  persist. They are on the right-hand side of an assignment \cite{wiki:lvalues}.
\end{itemize}

These two terms were replaced in Rust by \emph{place and value expressions}.
Value expressions represent actual values and are defined by exclusion from
place expressions. The latter evaluate to a \emph{place} which is essentially a
memory location~\cite{rustref}.

\begin{quote}
{[}Place{]} expressions are paths which refer to local variables,
{[}\ldots{]} dereferences (\passthrough{\lstinline!*expr!}), array
indexing expressions (\passthrough{\lstinline!expr[expr]!}), field
references (\passthrough{\lstinline!expr.f!}) {[}\ldots{]}. \\
\cite[section ``Expressions'']{rustref}
\end{quote}

Place expressions occur in \emph{place expression contexts} like on the
left-hand side of let-bindings, as borrow operands or as field expression
operands. Otherwise, if a place expression is evaluated in a \emph{value
context}, e.g.~on the right-hand side of a binding, it evaluates to what is
stored at the place it designates, its data is \emph{used}.

\subsubsection{Ownership}

As said previously, Rust's distinguishing feature is its ownership system which
is responsible for

\begin{quote}
{[enforcing]} an ownership invariant where a
variable is said to ``own'' the value it contains such that no two variables can
own the same value \cite[page 5]{lightweight-formalism}.
\end{quote}

In other words, data is owned by exactly one binding and if some data is used,
e.g. in an assignment or passed to a function, it will be \emph{moved out} of
that binding, i.e. the ownership of the data is transferred to the new binding.
The old binding is deinitialised and can never be reused. Moved data behaves
linearly \cite{oxide}, moving out can be seen as \emph{destructive read}
\cite{islands-alias-protection}. On line 2 of \autoref{lst:move}, data is moved
out of \lstinline!a! and its ownership is transferred to \lstinline!b!.

From \autoref{lst:move} it is clear, why Rust's borrow checker needs to be
flow-sensitive. The move semantics render \lstinline!a! dead before it formally
goes out of scope, e.g. at the end of the block. The same applies to individual
fields. A field can be moved out of its struct and become inaccessible while
another field of the same struct is still available. This is called a
\emph{partial move}. The struct itself also becomes inaccessible as soon as one
of its fields is moved.

\noindent\begin{minipage}[t]{.47\textwidth}
\begin{lstlisting}[
  language=Rust,
  label=lst:move,
  caption={A struct type with move semantics.}
]
let a = Container {
  pair: Some(123, 456)
};
let b = a;
// `a` can never be used again
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.47\textwidth}
\begin{lstlisting}[
  language=Rust,
  label=lst:copy,
  caption={Copy semantics of the \lstinline!i32! type.}
]
let a = 123;
let mut b = a;
b += 1;
// `a` can still be used
assert!(a == 123 && b == 124)
\end{lstlisting}
\end{minipage}

\paragraph{Move vs. Copy}

One departure from the move semantics are copyable types. Types that implement
the \lstinline!Copy! trait get copy semantics. The compiler automatically
implements that trait for primitive types\footnote{Primitive types in Rust are
booleans, characters, \lstinline!str!, numeric types and the panic type
\texttt{!}~\cite{rustref}} (cf. \autoref{lst:copy}) but also for shared
references and tuples of copyable types \cite[section "Special types and
traits"]{rustref}. When copyable data is used, it's implicitly copied and the
original binding stays valid and independent. In contrast to shared references
that are copyable, mutable references have move semantics because they need to
stay unique, as will become clear shortly. Non-copyable types can still be
explicitly copied by implementing the \lstinline!Clone! trait and calling the
\lstinline!clone! method.

\paragraph{Heap Allocation}

Up until now, all data was stack-allocated and hence, tied to the scope of the
surrounding function. To outlive a function, data needs to be heap-allocated
which is achieved in Rust with the \lstinline!Box<T>! type. Everything that is
put into a box is directly allocated on the heap (cf. \autoref{lst:box}). The
binding that ``holds the box'', \lstinline!c_heap! in the example, is the unique
owner of that data. But because boxes have move semantics, the ownership can be
transferred to other bindings, e.g. across function scopes.

\begin{lstlisting}[language=Rust, label=lst:box, caption={A heap-allocated container.}, style=short]
let c_heap = Box::new(Container { pair: None });
\end{lstlisting}

\subsubsection{References}
\label{references}

It is possible to read and even write data one does not own in Rust, through
references. In other words, they are the way to -- temporarily -- break away
from the ownership invariant~\cite{lightweight-formalism}. References are
created by \emph{borrowing} from a variable or field with the \lstinline!&! or
\lstinline!&mut! operator, depending on whether the created reference should be
mutable or not. One can either borrow from owned data directly or
\emph{reborrow} from an existing reference. Passing a reference to an object in
a function argument is called pass \emph{by reference}, as opposed to passing
the entire object \emph{by value} and hence moving or copying it. The method of
\autoref{lst:mut-ref-impl} is passed a mutable reference to the receiving
container instance and returns a reborrowed mutable reference  to the second
part of its tuple.

\begin{lstlisting}[
  language=Rust,
  label={lst:mut-ref-impl},
  caption={An implementation block with a trait bound. The method returns a mutable reference to some interior part of the struct.}
]
impl<K: Id, V> Container<K, V> {
  pub fn get_mut_by_id(&mut self, id: usize) -> Option<&mut V> {
    match &mut self.pair {
      Some((k, v)) if k.id() == id => Some(v),
      _ => None,
    }
  }
}
\end{lstlisting}

Rust's type system and borrow checking guarantee that all references are valid
when they are used. That is, use-after free errors are impossible and Rust also
prevents stack-allocated data from escaping its allocation scope. To do so, Rust
infers the \emph{lifetime} of each reference, i.e. the part of the program in
which the reference points to a valid variable and may still be used at a future
point of any execution path~\cite{wiki:live-vars}. A reference or variable that
is not used anymore is said to be \emph{dead}.

The lifetime of a reference in Rust is constrained by the lifetime of the
variable it borrows from, this is the main  mechanism to prevent use-after free
problems. Furthermore, there is a strict set of rules that borrows need to
adhere to. At any point of a program and for any data there can either exist

\begin{itemize}
\tightlist
\item multiple immutable, i.e.~\emph{shared references}, \lstinline!\&T!,  that
may read the referenced data,

\item or there can be a \emph{unique mutable reference},
\passthrough{\lstinline!\&mut T!}, that is allowed to read and write to the data
it does not own.
\end{itemize}

During the lifetime of a shared reference, the data can be read but not changed
by the owning binding as well. In contrast, the mutable reference allows to
change data without owning it under the condition that there exist no other
references to that data. While the mutable reference is live, even the owning
binding is neither allowed to read nor to write that place. In the words of
\citet{oxide}:

\begin{quote}
{[...]} we understand Rust's borrow checking system as ultimately being a system
for statically building a proof that data in memory is either
\emph{uniquely owned} (and thus able to allow unguarded mutation) or
\emph{collectively shared}, but not both.
\end{quote}

\subsection{Rust Compared to Scala}

\subsubsection{Mutability}

In Scala, there are local mutable variables (\passthrough{\lstinline!var!})
comparable to \passthrough{\lstinline!let mut!} in Rust. Class fields however
are immutable by default. At the class declaration one can opt into mutability
for a certain field by marking it as \lstinline!var!. That field is then mutable
on all instances of the class and irrespective of whether an instance is locally
bound with the immutable \lstinline!val! or the mutable \lstinline!var!.

\subsubsection{References}

Places or lvalues are not programatically accessible in Scala, as in JVM
languages there is no way to take a reference to a place explicitly. That means
it's impossible to generalise over whether one wants to assign to a local
variable or an object field by taking a reference to it.

As in all JVM languages, objects in Scala are heap-allocated and function
parameters are always passed by value. However, for objects this value is just a
reference to the object in the heap. This is very efficient for sharing
immutable objects while retaining by-value semantics. But as a consequence, the
by-value passing of references closely resembles by-reference passing for
mutable objects. The translation presented in \autoref{translation} will
extensively exploit this fact.


\section{Stainless Verifier}

With a solid understanding of Rust, it is time to introduce verification.
Stainless \cite{stainless} is a formal verification tool for Scala. It lets
programmers add contracts or specifications to functions and invariants to data
structures. Stainless then transforms the input program in multiple phases to a
purely functional language understood by its backend \emph{Inox} \cite{inox}
which tries to prove or disprove the contracts by using Z3 \cite{z3} or a
similar solver.

\subsection{Specifications}

The simplest example of a specification is shown in \autoref{lst:fact-scala}.
The expression in \lstinline!require! is called a \emph{precondition}, it has to
hold when the function is called, the \lstinline!ensuring! is a
\emph{postcondition} that must hold if the precondition holds. Simply put,
Stainless establishes just the latter, that the postconditions hold assuming the
preconditions hold. Of course, Stainless is more sophisticated and additionally
proves that the program finishes for all inputs (\emph{termination}), that
preconditions hold at static call sites of functions, that pattern matches are
exhaustive, and that the program does not crash at runtime (except for
out-of-memory errors) \cite{stainless-doc}. If these properties are invalid,
then Stainless finds a counter-example input for the function that leads to a
crash or violation of the specification.

\noindent\begin{minipage}[t]{.47\textwidth}
\begin{lstlisting}[
  language=Scala,
  label=lst:fact-scala,
  caption={The factorial with specifications.}
]
def fact(x: Int): Int = {
  require(x >= 0 && x < 10)
  if (x <= 0) 1
  else fact(x - 1) * x
} ensuring { r => r >= 0 }
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.47\textwidth}
\begin{lstlisting}[
  language=Rust,
  label=lst:fact-rust,
  caption={The factorial in Rust.}
]
#[pre(x >= 0 && x < 10)]
#[post(ret >= 0)]
pub fn fact(x: i32) -> i32 {
  if x <= 0 { 1 }
  else { fact(x - 1) * x }
}
\end{lstlisting}
\end{minipage}

As \autoref{lst:fact-rust} illustrates, the same function and specification is
also accepted by Rust-Stainless, which subsequently translates the program to
Stainless and lets it prove correctness. The only difference is that
specifications are added as function attributes rather than inline statements
and that postconditions in Rust automatically have a \lstinline!ret! variable in
scope that represents the return value. Other than that, the two are so similar
that the following sections of this chapter will only show examples in Rust for
simplicity. In both languages, one can in addition to specifications put
assertions into function bodies, in Rust with \lstinline"assert!" macro.
Stainless also proves that body assertions hold.

So far, an imprecision has been made about Stainless's input language. Stainless
does not support the full Scala language but rather a functional subset called
\emph{PureScala}. Expressions in specifications also need to be in PureScala.
However, Stainless was extended to support some form of mutability \cite{regb}
which this project relies upon. Chapter \ref{translation} will go into details
about how this is used.

The methods of the container in the running example (fully displayed in
\autoref{running-example}) show how the above features are applied to add
specifications. The \lstinline!implies! function in line 26 is a library helper
method provided by the \lstinline!stainless! crate. Body assertions are used in
the main function to ensure that the code behaves as expected.

\subsection{Algebraic Properties}
\label{laws-intro}

Traits are a very useful way of specifying mandatory interfaces in both Scala
and Rust. Common properties like equality and ordering are often modelled with
traits, but while the languages can enforce implementors of traits to provide
all abstract methods, they cannot enforce higher-level contracts. For example,
for an equality trait with \texttt{eq} one would assume that all implementations
are reflexive, i.e. $\forall x: x~\mathtt{eq}~x$. However, the compilers cannot
guarantee that.

As a solution, in Stainless one can specify contracts on traits. First, trait
methods can have all specification attributes like regular functions. These will
be checked to hold for all implementations. Furthermore, one can attach
\emph{laws} to traits i.e.~algebraic properties the contract implementors need
to fulfil \cite[section "Specifying Algebraic Properties"]{stainless-doc}.
Stainless proves correctness of the laws for each implementation of the trait.

The last addition to the running example, is a law on the \lstinline!Id! trait
stating  that ids need to be positive. Of course, the toy implementation that
hard-codes an id for strings, holds that contract (lines 7-8 in
\autoref{running-example}). A more interesting example of laws in
\autoref{lst:liskov1} shows a violation of the  Liskov Substitution principle
\cite{liskov}. The trait defines four methods. Two of them have regular
postconditions and the laws state that a change to the width should not change
the height and vice versa. Clearly, the implementation in \autoref{lst:liskov2}
holds these properties.

\begin{lstlisting}[language=Rust, caption={Example trait with laws.}, label={lst:liskov1}]
trait Rectangle {
  #[post(ret > 0)]
  fn width(&self) -> u32;
  #[post(ret > 0)]
  fn height(&self) -> u32;

  fn set_width(&self, width: u32) -> Self;
  fn set_height(&self, height: u32) -> Self;
  #[law]
  fn preserve_height(&self, any: u32) -> bool {
    self.set_width(any).height() == self.height()
  }
  #[law]
  fn preserve_width(&self, any: u32) -> bool {
    self.set_height(any).width() == self.width()
  }
}
\end{lstlisting}

Without the laws, it would be tempting to add a square implementation, see
\autoref{lst:liskov3}. However, the square changes both dimensions at once --
violating the laws. Stainless detects this, the square implementation fails
verification, and thereby a possible bug is caught.

\noindent
\begin{minipage}[t]{.49\textwidth}
\begin{lstlisting}[
  language=Rust,
  caption={Example implementation of the trait.},
  label={lst:liskov2},
  basicstyle=\footnotesize\ttfamily,
]
struct Rect {
  width: u32,
  height: u32
}
impl Rectangle for Rect {
  fn width(&self) -> u32 { self.width }
  fn height(&self) -> u32 { self.height }
  fn set_width(&self, width: u32) -> Self {
    Rect { width, height: self.height }
  }
  fn set_height(&self, height: u32) -> Self {
    Rect { width: self.width, height }
  }
}
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.49\textwidth}
\begin{lstlisting}[
  language=Rust,
  caption={Example implementation violating the laws.},
  label={lst:liskov3},
  basicstyle=\footnotesize\ttfamily,
]
struct Square {
  width: u32
}

impl Rectangle for Square {
  fn width(&self) -> u32 { self.width }
  fn height(&self) -> u32 { self.width }
  fn set_width(&self, width: u32) -> Self {
    Square { width }
  }
  fn set_height(&self, height: u32) -> Self {
    Square { width: height }
  }
}
\end{lstlisting}
\end{minipage}


This concludes this chapter's introduction on Rust and Stainless. All Rust
features needed for writing the motivating example (\autoref{running-example})
were introduced as well as the verification features of Rust-Stainless, at the
completion of this project. The goal of the remaining chapters is now to extend
Rust-Stainless with all the features required to verify the example. Most of
these features were added in the course of this thesis project. In particular,
\autoref{translation} will explain how mutability and mutable references are
translated to Scala. Chapter \ref{implementation} distinguishes between existing
and added features, then gives some implementation details.

\lstinputlisting[
  float,
  language=Rust,
  caption={The full running example for \autoref{background}. It showcases most of the newly introduced features of Rust-Stainless.},
  label={running-example}
]{code/thesis_example.rs}
