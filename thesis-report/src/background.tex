\section{Verification / Stainless}

\begin{itemize}
\tightlist
\item
  Support for FP
\item
  Support for mutability \& limitations
\end{itemize}

\section{Rust}

\begin{itemize}
\tightlist
\item
  intro to Rust
\item
  Here, we describe mainly features/specialities related to the
  translation
\end{itemize}

\TODO{The above is in bullet point stage (and not very far). The written out part starts here.}

\subsection{Liveness}

A variable is said to be \emph{live} if it holds a value that may be
used at any future point of the program.\cite{wiki:live-vars}
Otherwise, that variable is said to be \emph{dead}. This is for example
the case if the variable is reassigned before the next read. The part of
the program in which a variable is live is called its \emph{lifetime}.
The concept of \emph{liveness} is important in Rust as we will see
because it is central to the analysis of reference and borrow checking.

\subsection{Value categories}

In programming languages that expose memory management to the programmer
like C and Rust, one needs to distinguish between different \emph{value
categories} of a variable: \cite{wiki:lvalues}

\begin{itemize}
\tightlist
\item
  \emph{lvalues} are expressions that designate memory locations, for
  example variables, array elements etc. They are objects that have a
  storage address. The term originates from the fact that lvalues are on
  the left-hand side of an assignment.
\item
  \emph{rvalues} are expressions or temporary values that do not
  persist. They are on the right-hand side of an assignment.
\end{itemize}

These two terms have been used in Rust but were replaced by \emph{place
expressions} and \emph{value expressions}. Value expressions represent
actual values and are defined by exclusion from place expressions. Place
expressions evaluate to a \emph{place} in Rust which is essentially a
memory location.~\cite{rustref}

\begin{quote}
{[}Place{]} expressions are paths which refer to local variables,
{[}\ldots{]} dereferences (\passthrough{\lstinline!*expr!}), array
indexing expressions (\passthrough{\lstinline!expr[expr]!}), field
references (\passthrough{\lstinline!expr.f!}) {[}\ldots{]}. \\
\cite[section "Expressions"]{rustref}
\end{quote}

Place expressions occur in \emph{place expression contexts} like on the
left-hand side of let-bindings, as borrow operands, as field expression
operands or as pattern match scrutinees. Otherwise, if a place
expression is evaluated in a \emph{value context,} e.g.~on the
right-hand side of a binding, it evaluates to what is stored at the
place it evaluates to. We say, its data is \emph{used}.

\subsection{Mutability}

In Rust, mutability is declared at binding-time of new names, not at the
definition of data types. That means an object of some type can be
mutable or immutable depending on its binding
(e.g.~\passthrough{\lstinline!let!} or
\passthrough{\lstinline!let mut!}) but independently of the object's
type. Mutable variables, mutable references, fields of mutable variables
etc. are called \emph{mutable place expressions} and only they can be
used in \emph{mutable place expression contexts} like the left-hand side
of assignments and as operands of mutable borrows. The consequence is
that any field of any struct in Rust is \emph{possibly} mutable
depending on the binding of that instance.

\subsection{Owning \& referencing data}

\subsubsection{Ownership}

Rust's most distinguishing feature is that it is memory-safe without
need for a garbage collector. That is achieved by its novel approach to
\emph{data ownership} which is partly inspired by \emph{linear ownership
types} \citep{ownership-types} but goes much further.

The core principle of the ownership system is that \textbf{data is owned
by exactly one binding}. If some data is later used in an assignment or
passed to a function, it will be \emph{moved out} of that binding. The
binding is deinitialised and can never be reused, we say it behaves
linearly \cite{oxide}. One can also see moving out as \emph{destructive
read} \cite{islands-alias-protection} where the binding is dead after the read.
In \RefCode{lst:move},
data is moved out of \passthrough{\lstinline!a!} and its
ownership is transferred to \passthrough{\lstinline!b!}.

\begin{lstlisting}[
  language=Rust,
  label=lst:move,
  caption={A struct type with move semantics.}
]
struct A { a: i32 };
let a = A { a: 123 };
let b = a;
// `a` can never be used from here
\end{lstlisting}

One departure from these almost \emph{use once} \citep{use-once} variables are
copyable types. Types that implement the \passthrough{\lstinline!Copy!} trait in
Rust get copy semantics rather than move semantics. The compiler automatically
implements this for primitive types (numeric types cf. \RefCode{lst:copy},
\passthrough{\lstinline!char!}, \passthrough{\lstinline!bool!}) but also shared
references and tuples of copyable types \cite[section "Special
types and traits"]{rustref}. When data of these types is used, it's implicitly
copied and the original binding and data stay valid and independent.

\begin{lstlisting}[
  language=Rust,
  label=lst:copy,
  caption={Copy semantics of the \lstinline!i32! type.}
]
let a = 123;
let mut b = a;
b += 1;
// `a` can still be used and is == 123
\end{lstlisting}

For types that are not copyable, we are still able to explicitly create
copies of objects by implementing the \passthrough{\lstinline!Clone!}
trait and calling the \passthrough{\lstinline!Clone::clone!} method.

\subsubsection{References}

Reading and even writing data that one does not own is still possible in
Rust but has to be done with references. References are created by
\emph{borrowing} with the \passthrough{\lstinline!\&!} operator. One can
either borrow from owned data directly or one can \emph{reborrow} from
an existing reference. When passing a reference to an object as a
function argument, we say we pass that argument \emph{by reference,} as
opposed to passing the entire object \emph{by value} and hence moving or
copying it.

Rust's type system and borrow checking guarantee that all references are
always valid (e.g.~no use-after free is possible). This is possible
under a very strict set of rules. At any point in the program and for
any data there can either exist

\begin{itemize}
\tightlist
\item
  multiple immutable i.e.~\emph{shared references}
  \passthrough{\lstinline!\&T!} that may read the referenced data,
\item
  or there can be a \emph{unique mutable reference}
  \passthrough{\lstinline!\&mut T!} that is allowed to read and write
  to the data it does not own.
\end{itemize}

During the lifetime of a shared reference, the data can be read but not
changed by the owning binding. In contrast, the mutable reference allows
to change data without owning it under the condition that there exist no
other references to that data. While the mutable reference is live, even
the owning binding is neither allowed to read nor to write that place.

These rules underpin how Rust can ensure memory safety at compile time
and therefore form the core of the language. The type and borrow checker
of the Rust compiler enforce the rules or in the words of \citet{oxide}:

\begin{quote}
{[...]} we understand Rust's borrow checking system as ultimately being a system
for statically building a proof that data in memory is either
\emph{uniquely owned} (and thus able to allow unguarded mutation) or
\emph{collectively shared}, but not both.
\end{quote}

\subsection{Compared to Scala}

\subsubsection{Mutability}

In Scala, there are local mutable variables
(\passthrough{\lstinline!var!}) comparable to
\passthrough{\lstinline!let mut!} in Rust. Class fields however are
immutable by default. At the class declaration one can opt into
mutability for a certain field by marking it as
\passthrough{\lstinline!var!}. That field is then mutable on all
instances of the class and irrespective of whether an instance is
locally bound with the immutable \passthrough{\lstinline!val!} or the
mutable \passthrough{\lstinline!var!}.

\subsubsection{References}

Places or lvalues are not programatically accessible in Scala, as in JVM
languages there is no way to take a reference to a place explicitly.
That means it's impossible to generalise over whether one wants to
assign to a local variable or an object field by taking a reference and
assigning to the dereference.

As in all JVM languages, objects in Scala are heap-allocated and
function parameters are always passed by value. However, for objects
this value is just a reference to the object in the heap. This is very
efficient for sharing immutable objects but retaining by-value
semantics. But as a consequence, the by value passing of references
closely resembles by reference passing if an object is mutable. The
translation presented in \RefChapter{translation} will extensively exploit this fact.
