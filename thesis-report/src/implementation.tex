The Rust-Stainless tool is developed as a Rust open source software
project.\footnote{\url{https://github.com/epfl-lara/rust-stainless/}} It was
created by Georg Schmid to explore a new frontend to Stainless for the Rust
language. This thesis project substantially extends the fragment of Rust code
that the tool supports. With the thesis' completion, the source repository
contains approximately 12K lines of Rust code and over 70 files or 3K lines of
Rust test examples. Most features described here are available on the
\lstinline!master! branch, except for the mutability translation that can be
found on the \lstinline!mutable-cells!
branch.\footnote{\url{https://github.com/epfl-lara/rust-stainless/pull/164}}

Before presenting the design of the tool and some details of its implementation,
we provide some  background on the Rust compiler and its phases. Then we will
see what language features the tool was already capable of extracting before
this thesis project and what new features have been introduced.


\section{Background}

\subsection{Rust Compiler}

To make the translation of Rust code manageable and minimise the amount of
busy-work the tool needs to do, it heavily relies on the Rust compiler
\cite{rustc-guide}, \passthrough{\lstinline!rustc!}. The compiler takes Rust
source code as input and produces an executable binary. This process involves
multiple phases in each of which the high-level input source is transformed or
\emph{lowered} into a more low-level representation. We will proceed by giving a
brief overview of the compilation process.

The Rust compiler always operates on a single crate. That is, each crate is
compiled separately and maybe linked to other crates only after compilation.
This means that the \emph{intermediate representations} described afterwards are
only available for items of the current crate. The exception is for some
metadata of public items like function signatures that need to be accessible
across crates.

The first two compilation phases are concerned with transforming the input text
source into a token stream -- lexing -- and then into an \emph{abstract syntax
tree (AST)} -- parsing. First syntactical validations, name resolutions and
macro expansion are performed on the AST. While the AST is already a
representation of the program, it still maps directly to the source code and can
be seen as a data structure representation of the source text.

The first intermediate representation (IR) constructed from the AST is
the \emph{high-level IR (HIR)}. This is the first IR in that it contains
much less high-level features, because many have been desugared. The HIR
is used to type check the program. In that process an even lower-level
IR is created, the \emph{typed HIR (THIR)}. Still in the form of a tree,
this IR contains the full explicit type information.

The THIR is subsequently used to construct the \emph{mid-level IR (MIR)}
that has the form of a \emph{control-flow graph (CFG)}. Such a graph is
a diagram that consists of \emph{basic blocks} of code and arrows
between them that represent all the possible paths the control flow can
take. The MIR still has generic types but because it is a CFG it is much
more convenient for performing things like liveness analysis,
optimisations, and most importantly, the borrow check of the program.

The last phase of compilation is the \emph{code generation} phase. In
that step the generic code is \emph{monomorphised} i.e.~copied and
output for each type it is instantiated with. Then a special IR for the
compiler backend framework \emph{LLVM} \cite{llvm} is generated. LLVM
will perform much more performance optimisations and finally generate
the assembly code.

\section{System Overview}

\subsection{Design}

The Rust-Stainless verification system consists of multiple components,
most of which are implemented as their own Rust crate. Each component
modularly fulfils a step in the overarching goal of taking Rust code,
transforming it for Stainless and getting a verification result back. In
that sense, Rust-Stainless is an alternative frontend to Stainless for
Rust, much like the Rust compiler is an alternative frontend to LLVM.

Rust-Stainless itself has a frontend and a backend.
\lstinline!stainless_frontend! is the frontend crate of the tool and contains
two executables with which the tool is started and which deal with command line
arguments. The subcommand for the Cargo build tool \passthrough{\lstinline!cargo
stainless!} is the most common way of running Rust-Stainless. Internally, it
calls the second stand-alone binary \lstinline!rustc_to_stainless! which runs
the actual frontend of the tool.

The programmer also sees another interface of Rust-Stainless, its
library \lstinline!libstainless!. The library needs to be
imported as \passthrough{\lstinline!extern crate stainless;!} in all
code that is to be verified. It provides the user-facing parts of
Rust-Stainless like the specification macros and some built-in Stainless
types useful for specification: an immutable generic set and map.

The main work of the translation is performed by the
\passthrough{\lstinline!stainless\_extraction!} crate. The frontend
calls the method \passthrough{\lstinline!extract\_crate!} which
retrieves the HIR from the compiler and translates it to Stainless AST
with the help of another crate,
\passthrough{\lstinline!stainless\_data!}. The latter contains the
auto-generated Rust definitions of the Stainless ASTs as well as code to
serialise them to a binary format.

Finally, \passthrough{\lstinline!stainless\_backend!} is responsible for
spawning and interacting with a JVM subprocess of the actual Stainless
executable. The executable consist of the normal Stainless verification
pipeline but with a custom entry-point called
\passthrough{\lstinline!Noxt-Frontend!}. ``Noxt'' stands for \emph{no
extraction} which means it takes as input serialised trees instead of
extracting trees from the Scala compiler output.

\begin{quote}
\TODO{diagram for this}
\end{quote}

\subsection{Pipeline}

Knowing the system's components, we can trace the path of an exemplary
program through the pipeline in more detail. This will allow us to
understand some of the design decisions made.

\begin{lstlisting}[
  language=Rust,
  caption={Example Rust program with a post-condition.},
  label={lst:example}
]
extern crate stainless;
use stainless::*;

struct A(i32);

#[post(ret.0 >= 0)]
fn f(a: A) -> A {
  A(a.0 * a.0)
}
\end{lstlisting}

In \RefCode{lst:example}, the Stainless library is added as an external crate
and then imported such that the post-condition specification attribute
\passthrough{\lstinline!\#[post()]!} is available. The attribute is implemented
as a procedural macro\footnote{Procedural macros invoke user-provided code at
compilation-time and hence, allow for more complex transformations of the AST
inside a macro \cite[section "Procedural Macros"]{rustref}.} and will be
expanded to a closure inside the function (\RefCode{lst:example2}).

\begin{lstlisting}[
  language=Rust,
  caption={Desugared post-condition.},
  label={lst:example2}
]
fn f(a: A) -> A {
  #[clippy::stainless::post]
  |a: A, ret: A| -> bool {ret.0 >= 0};
  A(a.0 * a.0)
}
\end{lstlisting}

Rust-Stainless leverages the heavy lifting done by the Rust compiler. The
frontend invokes the compiler via the \passthrough{\lstinline!rustc\_driver!}
library and runs all the phases until all analyses are complete and pass,
otherwise the tool fails with the error given by
\passthrough{\lstinline!rustc!}. In particular, the compiler does the lexing,
parsing, macro expansion and IR construction. Secondly, the compiler type and
borrow checks the program. This way, we achieve our strong assumption from
\RefSec{correctness-claim} because Rust-Stainless only continues if all checks
pass.

Once analysis is complete, the extraction module is invoked on the HIR.
As Rust's compile model prescribes that the HIR is only ever constructed
for the current crate, our toll also only translates the current crate.
We further examine that limitation of our implementation in \RefSec{impl-limitations}.

The extraction traverses all the \emph{items} of the crate, that is top-level
functions, structs, enums, \passthrough{\lstinline!impl!} blocks and their
methods as well as traits. It directly constructs Stainless definitions for
datatypes. For function and method bodies, the extraction works on the THIR,
which is guaranteed to exist as the type check passed. The body of our example
function in THIR can be seen in \RefApp{apx:thir-example}.

The HIR is very well suited for translation to Stainless AST because it is still
in the form of an AST but all the type information is explicit and implicit
features like method calls and dereferences have been resolved or desugared.
That way, the THIR is the representation that is the closest to Stainless AST
which makes translation simpler. The downside of working with the THIR instead
of the MIR is that lifetime resolution is performed on the MIR. Hence, in the
THIR there is no way of knowing the exact point where a binding or reference
ends its lifetime. This is a serious limitation if one needs the lifetimes in
the translation, for example for some other encoding of mutability as explored
in \RefSec{impl-limitations}.


If all the THIR can be translated to Stainless AST without errors,
i.e.~there are no unsupported features in the program, the AST is
serialised to the custom binary format that is used by Stainless'
caching mechanism. At this point, the program consists of a list of
functions, a list of ADTs and a list of classes (\RefCode{lst:stainless-trees}).

\begin{lstlisting}[
  language=Scala,
  label={lst:stainless-trees},
  caption={Extracted Stainless ADTs and functions, printed as code.}
]
sealed case class A(_0: MutCell[Int])
sealed case class MutCell[T @mutable]((value: T @mutable) @var)

@pure def f(a: A): A = {
  freshCopy(A(MutCell[Int](a._0.value * a._0.value)))
} ensuring {
  (ret: A) => ret._0.value >= 0
}
\end{lstlisting}

Either the user specified to export the AST in which case the binary format is
simply written to a file, or the Stainless backend is started. Rust-Stainless
spawns a subprocess with the \passthrough{\lstinline!Noxt-Frontend!} of
Stainless and communicates with it via standard input and output. The subprocess
reads the AST from a temporary file, performs some minor transformation and
passes it through the verification pipeline. In the end, it reports back the
results in JSON format such that Rust-Stainless can print them. In the case of
the example, Stainless tells us that there is a problem: the multiplication on
line 5 of \RefCode{lst:stainless-trees} could overflow and therefore, the
post-condition does not hold.



\section{Extraction}

\subsection{Supported Rust features}

\subsubsection{Existing features}

The initial fragment of the Rust language that the tool could extract
and translate underlay strict restrictions: all code needed to be
functional, immutable and the only allowed side-effect was
\passthrough{\lstinline"panic!"}. References, heap allocation with boxes
and with it recursive data types were impossible.

Apart from that, the majority of the language was already supported,
i.e.~most of the control flow syntax, top-level functions with bodies,
integer and boolean expressions, string literals, pattern matching, type
parameters, generics, etc. \emph{Algebraic data types (ADTs)} were
supported, including tuples (without pattern matching) and generics.

Function specifications (specs), that is pre- and postconditions, could
be stated with the two attributes from the
\passthrough{\lstinline!libstainless!} crate:
\passthrough{\lstinline!pre!} and \passthrough{\lstinline!post!}. The
argument of a spec is a regular Rust expression that needs to type and
borrow check, but it must have no effect on any variables of the
function body.

In the absence of references, the borrow checking of spec expressions
posed a problem because oftentimes the expression would consume a
function parameter of moved type multiple times which does not borrow
check. As a work-around, one could add multiple specs of the same kind
to a function which is equivalent to multiple
\passthrough{\lstinline!\&\&!}-concatenated expressions. With all that,
an example of supported and verified Rust code is the following:

\begin{lstlisting}[language=Rust]
pub fn i32_ops(x: i32, y: i32) {
  assert!(x + y == 2 * x);
  if x >= 0 && x < 1<<30 {
    assert!(x == (x + x) / 2);
  }
}

enum Maybe<T> {
  Nothing,
  Just { value: T }
}

fn get_or<T>(maybe: Maybe<T>, default: T) -> T {
  match maybe {
    Maybe::Nothing => default,
    Maybe::Just { value } => value,
  }
}

#[pre(x >= 0)]
#[pre(x < 10)]
#[post(ret >= 0)]
pub fn fact(x: i32) -> i32 {
  if x <= 0 { 1 }
  else { fact(x - 1) * x }
}
\end{lstlisting}

\subsubsection{New features}

We turn to give an overview of all the language features that were added
to the extraction in the course of this thesis project except for the
mutability which has been introduced in \RefChapter{translation}. The
features described here have been merged to the
\passthrough{\lstinline!master!} branch of the project by a series of
pull requests. You can find more implementation details about each
feature in said pull requests.

\paragraph{Syntactical and Notational Improvements}

Support was added for:

\begin{itemize}
\item
  \passthrough{\lstinline!else if!} expressions,
\item
  \passthrough{\lstinline!let!} bindings with a user-specified type
  annotation, \passthrough{\lstinline!let t: u16 = 1;!},
\item
  pattern matching on tuples,
\item
  accessing tuple struct fields by their numerical identifier,
  \passthrough{\lstinline!A(2, 3).0!},
\item
  usage of the \passthrough{\lstinline!return!} keyword at most points
  of a function (but not in if conditions and guards),
\item
  \passthrough{\lstinline!usize!} and \passthrough{\lstinline!isize!}
  integer types that have the size of a pointer on the targeted
  platform,
\item
  \emph{struct update syntax,} a short-hand notation for creating a
  struct from an existing one,

\begin{lstlisting}[language=Rust]
struct A { a: i32, b: bool, c: char }
let x: A = A { a: 123, b: true, c: 'c' };
let y: A = A { b: false, ..x }; // copies `x.b`, `x.c`
\end{lstlisting}
\item
  crate local modules and imports, which includes the ability of
  splitting up a crate into multiple files, and finally,
\item
  panics in expression locations like an arm of a pattern match.

\begin{lstlisting}[language=Rust]
match Option::Some(123) {
  Option::Some(x) => x,
  Option::None => panic!("no value"),
}
\end{lstlisting}
\end{itemize}

\paragraph{Immutable References and Heap Allocation}

It is now possible to immutably borrow places, pass immutable references
around and allocate data on the heap with
\passthrough{\lstinline!Box::new!}. Although already presented in
\RefChapter{translation}, we mention the feature here because it exists
independently of the mutability translation. This enables recursive data
types like the typical, functional linked-list.

\begin{lstlisting}[language=Rust]
pub enum List<T> {
  Nil,
  Cons(T, Box<List<T>>),
}
\end{lstlisting}

Additionally, this eases the problem of borrow-checking spec expressions
because expressions that only read data, like we assume most
specifications do, can now take a reference instead of consuming the
data.

\paragraph{Measure attribute}

Recursive proofs in Stainless often require the programmer to state the
induction variable with a \passthrough{\lstinline!decreases!} call. This
helps Stainless infer the so called \emph{measure} of the proof, with
which it checks termination. The same feature was introduced as a new
spec attribute which enables verification of recursive functions.

\begin{lstlisting}[
  language=Rust,
  caption={Measure attribute.}
]
#[measure(l)]
fn size<T>(l: &List<T>) -> u32 {
  match l {
    List::Nil => 0,
    List::Cons(_, tail) => 1 + size(tail),
  }
}
\end{lstlisting}

\paragraph{Stainless library}

As explained above, the \passthrough{\lstinline!libstainless!} crate is
exposed to the programmer and contains helpers for specifying proofs and
conditions. This is the equivalent of the
\passthrough{\lstinline!stainless!} package in Scala. In addition to the
pre-, post- and measure attributes the
\passthrough{\lstinline!libstainless!} now offers an immutable, infinite
set \passthrough{\lstinline!stainless::Set<T>!} and map
\passthrough{\lstinline!stainless::Map<K, V>!} implementation.

In extraction and verification, both of these types are translated to
the Stainless built-in infinite set and map type. Hence, they are backed
and well-understood by Stainless which enables their utility in proofs.
At runtime of the verified program however, the collections are backed
with a runnable implementation that relies on the
\passthrough{\lstinline!im!} crate for the immutable set and map
implementations. The Rust interface of the collections was designed so
as to resemble the \passthrough{\lstinline!std::collections::HashSet!}
and \passthrough{\lstinline!HashMap!} as closely as possible.

\begin{lstlisting}[
  language=Rust,
  caption={The interface of the Stainless collections in Rust.}
]
Set<T> {
  fn new() -> Self;
  fn singleton(t: T) -> Self;
  fn insert(&self, t: T) -> Self;
  fn contains(&self, t: &T) -> bool;
  fn union(self, other: Set<T>) -> Self;
  fn intersection(self, other: Set<T>) -> Self;
  fn difference(self, other: Set<T>) -> Self;
  fn is_subset(&self, other: &Set<T>) -> bool;
}
Map<K, V> {
  fn new() -> Self;
  fn get(&self, key: &K) -> Option<&V>;
  fn get_or<'a>(&'a self, key: &K, elze: &'a V);
  /// Panics if the key is not in the map.
  fn index(&self, key: &K) -> &V;
  fn contains_key(&self, key: &K) -> bool;
  fn insert(&self, key: K, val: V) -> Self;
  fn remove(&self, key: &K) -> Self;
}
\end{lstlisting}

Furthermore, the library provides a helper function
\passthrough{\lstinline!implies!} that let's one write the logical
implication $p \implies q \equiv \neg{p} \land q$ over boolean expressions.





\section{Limitations}
\label{impl-limitations}
