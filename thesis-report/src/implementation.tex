The Rust-Stainless tool is developed as an open source software
project.\footnote{\url{https://github.com/epfl-lara/rust-stainless/}} It was
created by Georg Schmid to explore a new frontend to Stainless for the Rust
language. Upon completion of this thesis project, the tool is implemented in
approximately 12K lines of Rust code. Most features described here are available
on the \lstinline!master! branch, except for the mutability translation that
lives on the \lstinline!mutable-cells!
branch.\footnote{\url{https://github.com/epfl-lara/rust-stainless/pull/164}}

Before presenting the design of the tool and some details of its implementation,
we provide some  background on the Rust compiler and its phases. Then we will
see what language features the tool was already capable of extracting before
this thesis project and what new features have been introduced.


\section{Background}

\subsection{Rust Compiler}

To make the translation of Rust code manageable and minimise the amount of
busy-work the tool needs to do, it heavily relies on the Rust compiler
\cite{rustc-guide}, \passthrough{\lstinline!rustc!}. The compiler takes Rust
source code as input and produces an executable binary. This process involves
multiple phases in each of which the high-level input source is transformed or
\emph{lowered} into a more low-level representation. We will proceed by giving a
brief overview of the compilation process.

The Rust compiler always operates on a single crate. That is, each crate is
compiled separately and maybe linked to other crates only after compilation.
This means that the \emph{intermediate representations} described afterwards are
only available for items of the current crate. The exception is for some
metadata of public items like function signatures that need to be accessible
across crates.

The first two compilation phases are concerned with transforming the input text
source into a token stream -- lexing -- and then into an \emph{abstract syntax
tree (AST)} -- parsing. First syntactical validations, name resolutions and
macro expansion are performed on the AST. While the AST is already a
representation of the program, it still maps directly to the source code and can
be seen as a data structure representation of the source text.

The first intermediate representation (IR) constructed from the AST is
the \emph{high-level IR (HIR)}. This is the first IR in that it contains
much less high-level features, because many have been desugared. The HIR
is used to type check the program. In that process an even lower-level
IR is created, the \emph{typed HIR (THIR)}. Still in the form of a tree,
this IR contains the full explicit type information.

The THIR is subsequently used to construct the \emph{mid-level IR (MIR)}
that has the form of a \emph{control-flow graph (CFG)}. Such a graph is
a diagram that consists of \emph{basic blocks} of code and arrows
between them that represent all the possible paths the control flow can
take. The MIR still has generic types but because it is a CFG it is much
more convenient for performing things like liveness analysis,
optimisations, and most importantly, the borrow check of the program.

The last phase of compilation is the \emph{code generation} phase. In
that step the generic code is \emph{monomorphised} i.e.~copied and
output for each type it is instantiated with. Then a special IR for the
compiler backend framework \emph{LLVM} \cite{llvm} is generated. LLVM
will perform much more performance optimisations and finally generate
the assembly code.

\section{System Overview}

\subsection{Design}

The Rust-Stainless verification system consists of multiple components,
most of which are implemented as their own Rust crate. Each component
modularly fulfils a step in the overarching goal of taking Rust code,
transforming it for Stainless and getting a verification result back. In
that sense, Rust-Stainless is an alternative frontend to Stainless for
Rust, much like the Rust compiler is an alternative frontend to LLVM.

Rust-Stainless itself has a frontend and a backend.
\lstinline!stainless_frontend! is the frontend crate of the tool and contains
two executables with which the tool is started and which deal with command line
arguments. The subcommand for the Cargo build tool \passthrough{\lstinline!cargo
stainless!} is the most common way of running Rust-Stainless. Internally, it
calls the second stand-alone binary \lstinline!rustc_to_stainless! which runs
the actual frontend of the tool.

The programmer also sees another interface of Rust-Stainless, its
library \lstinline!libstainless!. The library needs to be
imported as \passthrough{\lstinline!extern crate stainless;!} in all
code that is to be verified. It provides the user-facing parts of
Rust-Stainless like the specification macros and some built-in Stainless
types useful for specification: an immutable generic set and map.

The main work of the translation is performed by the
\passthrough{\lstinline!stainless\_extraction!} crate. The frontend
calls the method \passthrough{\lstinline!extract\_crate!} which
retrieves the HIR from the compiler and translates it to Stainless AST
with the help of another crate,
\passthrough{\lstinline!stainless\_data!}. The latter contains the
auto-generated Rust definitions of the Stainless ASTs as well as code to
serialise them to a binary format.

Finally, \passthrough{\lstinline!stainless\_backend!} is responsible for
spawning and interacting with a JVM subprocess of the actual Stainless
executable. The executable consist of the normal Stainless verification
pipeline but with a custom entry-point called
\passthrough{\lstinline!Noxt-Frontend!}. ``Noxt'' stands for \emph{no
extraction} which means it takes as input serialised trees instead of
extracting trees from the Scala compiler output.

\begin{quote}
\TODO{diagram for this}
\end{quote}

\subsection{Pipeline}
\label{sec:pipeline}

Knowing the system's components, we can trace the path of an exemplary
program through the pipeline in more detail. This will allow us to
understand some of the design decisions made.

\begin{lstlisting}[
  language=Rust,
  caption={Example Rust program with a post-condition.},
  label={lst:example}
]
extern crate stainless;
use stainless::*;

struct A(i32);

#[post(ret.0 >= 0)]
fn f(a: A) -> A {
  A(a.0 * a.0)
}
\end{lstlisting}

In \autoref{lst:example}, the Stainless library is added as an external crate
and then imported such that the post-condition specification attribute
\passthrough{\lstinline!\#[post()]!} is available. The attribute is implemented
as a procedural macro\footnote{Procedural macros invoke user-provided code at
compilation-time and hence, allow for more complex transformations of the AST
inside a macro \cite[section "Procedural Macros"]{rustref}.} and will be
expanded to a closure inside the function (\autoref{lst:example2}).

\begin{lstlisting}[
  language=Rust,
  caption={Desugared post-condition.},
  label={lst:example2}
]
fn f(a: A) -> A {
  #[clippy::stainless::post]
  |a: A, ret: A| -> bool {ret.0 >= 0};
  A(a.0 * a.0)
}
\end{lstlisting}

Rust-Stainless leverages the heavy lifting done by the Rust compiler. The
frontend invokes the compiler via the \passthrough{\lstinline!rustc\_driver!}
library and runs all the phases until all analyses are complete and pass,
otherwise the tool fails with the error given by
\passthrough{\lstinline!rustc!}. In particular, the compiler does the lexing,
parsing, macro expansion and IR construction. Secondly, the compiler type and
borrow checks the program. This way, we achieve our strong assumption from
\autoref{correctness-claim} because Rust-Stainless only continues if all checks
pass.

Once analysis is complete, the extraction module is invoked on the HIR.
As Rust's compile model prescribes that the HIR is only ever constructed
for the current crate, our toll also only translates the current crate.
We further examine that limitation of our implementation in \autoref{impl-limitations}.

The extraction traverses all the \emph{items} of the crate, that is top-level
functions, structs, enums, \passthrough{\lstinline!impl!} blocks and their
methods as well as traits. It directly constructs Stainless definitions for
datatypes. For function and method bodies, the extraction works on the THIR,
which is guaranteed to exist as the type check passed. The body of our example
function in THIR can be seen in \autoref{apx:thir-example}.

The HIR is very well suited for translation to Stainless AST because it is still
in the form of an AST but all the type information is explicit and implicit
features like method calls and dereferences have been resolved or desugared.
That way, the THIR is the representation that is the closest to Stainless AST
which makes translation simpler. The downside of working with the THIR instead
of the MIR is that lifetime resolution is performed on the MIR. Hence, in the
THIR there is no way of knowing the exact point where a binding or reference
ends its lifetime. This is a serious limitation if one needs the lifetimes in
the translation, for example for some other encoding of mutability as explored
in \autoref{impl-limitations}.


If all the THIR can be translated to Stainless AST without errors,
i.e.~there are no unsupported features in the program, the AST is
serialised to the custom binary format that is used by Stainless'
caching mechanism. At this point, the program consists of a list of
functions, a list of ADTs and a list of classes (\autoref{lst:stainless-trees}).

\begin{lstlisting}[
  language=Scala,
  label={lst:stainless-trees},
  caption={Extracted Stainless ADTs and functions, printed as code.}
]
sealed case class A(_0: MutCell[Int])
sealed case class MutCell[T @mutable]((value: T @mutable) @var)

@pure def f(a: A): A = {
  freshCopy(A(MutCell[Int](a._0.value * a._0.value)))
} ensuring {
  (ret: A) => ret._0.value >= 0
}
\end{lstlisting}

Either the user specified to export the AST in which case the binary format is
simply written to a file, or the Stainless backend is started. Rust-Stainless
spawns a subprocess with the \passthrough{\lstinline!Noxt-Frontend!} of
Stainless and communicates with it via standard input and output. The subprocess
reads the AST from a temporary file, performs some minor transformation and
passes it through the verification pipeline. In the end, it reports back the
results in JSON format such that Rust-Stainless can print them. In the case of
the example, Stainless tells us that there is a problem: the multiplication on
line 5 of \autoref{lst:stainless-trees} could overflow and therefore, the
post-condition does not hold.



\section{Extraction}

\subsection{Supported Rust features}
\label{sec:supported-features}

\subsubsection{Existing features}

The initial fragment of the Rust language that the tool could extract
and translate underlay strict restrictions: all code needed to be
functional, immutable and the only allowed side-effect was
\passthrough{\lstinline"panic!"}. References, heap allocation with boxes
and with it recursive data types were impossible.

Apart from that, the majority of the language was already supported,
i.e.~most of the control flow syntax, top-level functions with bodies,
integer and boolean expressions, string literals, pattern matching, type
parameters, generics, etc. \emph{Algebraic data types (ADTs)} were
supported, including tuples (without pattern matching) and generics.

Function specifications (specs), that is pre- and postconditions, could
be stated with the two attributes from the
\passthrough{\lstinline!libstainless!} crate:
\passthrough{\lstinline!pre!} and \passthrough{\lstinline!post!}. The
argument of a spec is a regular Rust expression that needs to type and
borrow check, but it must have no effect on any variables of the
function body.

In the absence of references, the borrow checking of spec expressions
posed a problem because oftentimes the expression would consume a
function parameter of moved type multiple times which does not borrow
check. As a work-around, one could add multiple specs of the same kind
to a function which is equivalent to multiple
\passthrough{\lstinline!\&\&!}-concatenated expressions. With all that,
an example of supported and verified Rust code is the following:

\begin{lstlisting}[language=Rust]
pub fn i32_ops(x: i32, y: i32) {
  assert!(x + y == 2 * x);
  if x >= 0 && x < 1<<30 {
    assert!(x == (x + x) / 2);
  }
}

enum Maybe<T> {
  Nothing,
  Just { value: T }
}

fn get_or<T>(maybe: Maybe<T>, default: T) -> T {
  match maybe {
    Maybe::Nothing => default,
    Maybe::Just { value } => value,
  }
}

#[pre(x >= 0)]
#[pre(x < 10)]
#[post(ret >= 0)]
pub fn fact(x: i32) -> i32 {
  if x <= 0 { 1 }
  else { fact(x - 1) * x }
}
\end{lstlisting}

\subsubsection{New features}

We turn to give an overview of all the language features that were added
to the extraction in the course of this thesis project except for the
mutability which has been introduced in \autoref{translation}. The
features described here have been merged to the
\passthrough{\lstinline!master!} branch of the project by a series of
pull requests. You can find more implementation details about each
feature in said pull requests.

\paragraph{Syntactical and Notational Improvements}

Support was added for:

\begin{itemize}
\item
  \passthrough{\lstinline!else if!} expressions,
\item
  \passthrough{\lstinline!let!} bindings with a user-specified type
  annotation, \passthrough{\lstinline!let t: u16 = 1;!},
\item
  pattern matching on tuples,
\item
  accessing tuple struct fields by their numerical identifier,
  \passthrough{\lstinline!A(2, 3).0!},
\item
  usage of the \passthrough{\lstinline!return!} keyword at most points
  of a function (but not in if conditions and guards),
\item
  \passthrough{\lstinline!usize!} and \passthrough{\lstinline!isize!}
  integer types that have the size of a pointer on the targeted
  platform,
\item
  \emph{struct update syntax,} a short-hand notation for creating a
  struct from an existing one,

\begin{lstlisting}[language=Rust]
struct A { a: i32, b: bool, c: char }
let x: A = A { a: 123, b: true, c: 'c' };
let y: A = A { b: false, ..x }; // copies `x.b`, `x.c`
\end{lstlisting}
\item
  crate local modules and imports, which includes the ability of
  splitting up a crate into multiple files, and finally,
\item
  panics in expression locations like an arm of a pattern match.

\begin{lstlisting}[language=Rust]
match Option::Some(123) {
  Option::Some(x) => x,
  Option::None => panic!("no value"),
}
\end{lstlisting}
\end{itemize}

\paragraph{Immutable References and Heap Allocation}

It is now possible to immutably borrow places, pass immutable references
around and allocate data on the heap with
\passthrough{\lstinline!Box::new!}. Although already presented in
\autoref{translation}, we mention the feature here because it exists
independently of the mutability translation. This enables recursive data
types like the typical, functional linked-list.

\begin{lstlisting}[language=Rust]
pub enum List<T> {
  Nil,
  Cons(T, Box<List<T>>),
}
\end{lstlisting}

Additionally, this eases the problem of borrow-checking spec expressions
because expressions that only read data, like we assume most
specifications do, can now take a reference instead of consuming the
data.

\paragraph{Measure attribute}

Recursive proofs in Stainless often require the programmer to state the
induction variable with a \passthrough{\lstinline!decreases!} call. This
helps Stainless infer the so called \emph{measure} of the proof, with
which it checks termination. The same feature was introduced as a new
spec attribute which enables verification of recursive functions.

\begin{lstlisting}[
  language=Rust,
  caption={Measure attribute.}
]
#[measure(l)]
fn size<T>(l: &List<T>) -> u32 {
  match l {
    List::Nil => 0,
    List::Cons(_, tail) => 1 + size(tail),
  }
}
\end{lstlisting}

\paragraph{Stainless library}

As explained above, the \passthrough{\lstinline!libstainless!} crate is
exposed to the programmer and contains helpers for specifying proofs and
conditions. This is the equivalent of the
\passthrough{\lstinline!stainless!} package in Scala. In addition to the
pre-, post- and measure attributes the
\passthrough{\lstinline!libstainless!} now offers an immutable, infinite
set \passthrough{\lstinline!stainless::Set<T>!} and map
\passthrough{\lstinline!stainless::Map<K, V>!} implementation.

In extraction and verification, both of these types are translated to
the Stainless built-in infinite set and map type. Hence, they are backed
and well-understood by Stainless which enables their utility in proofs.
At runtime of the verified program however, the collections are backed
with a runnable implementation that relies on the
\passthrough{\lstinline!im!} crate for the immutable set and map
implementations. The Rust interface of the collections was designed so
as to resemble the \passthrough{\lstinline!std::collections::HashSet!}
and \passthrough{\lstinline!HashMap!} as closely as possible.

\begin{lstlisting}[
  language=Rust,
  caption={The interface of the Stainless collections in Rust.}
]
Set<T> {
  fn new() -> Self;
  fn singleton(t: T) -> Self;
  fn insert(&self, t: T) -> Self;
  fn contains(&self, t: &T) -> bool;
  fn union(self, other: Set<T>) -> Self;
  fn intersection(self, other: Set<T>) -> Self;
  fn difference(self, other: Set<T>) -> Self;
  fn is_subset(&self, other: &Set<T>) -> bool;
}
Map<K, V> {
  fn new() -> Self;
  fn get(&self, key: &K) -> Option<&V>;
  fn get_or<'a>(&'a self, key: &K, elze: &'a V);
  /// Panics if the key is not in the map.
  fn index(&self, key: &K) -> &V;
  fn contains_key(&self, key: &K) -> bool;
  fn insert(&self, key: K, val: V) -> Self;
  fn remove(&self, key: &K) -> Self;
}
\end{lstlisting}

Furthermore, the library provides a helper function
\passthrough{\lstinline!implies!} that let's one write the logical
implication $p \implies q \equiv \neg{p} \land q$ over boolean expressions.


\paragraph{External and Synthesised ADTs}

Internally, the \lstinline!Map<K, V>! of the Stainless crate relies on
the \passthrough{\lstinline!MutableMap!} of Scala Stainless with a value
type of \passthrough{\lstinline!Option[V]!}. To perform that
translation, the extraction needs to create trees of the
\passthrough{\lstinline!Option!} type even if the
\passthrough{\lstinline!std::option::Option!} doesn't occur in the
program. Therefore, Rust-Stainless can now synthesise values and types
for certain specific ADTs: the \passthrough{\lstinline!Option!}, tuples
and mutable cells as described in \autoref{sec:translation}.

Related to the above, the frontend also supports extraction of
crate-external ADTs like \passthrough{\lstinline!Option!} and
\passthrough{\lstinline!std::result::Result!}. This means, the
programmer can use the standard structures and they will be correctly
translated, provided that no methods on these types are used. Other than
ADT definitions that are available across crates, function bodies only
live in the HIR which is only ever available for the currently compiled
crate.

\paragraph{Implementation Blocks, Traits and Laws}

Methods on types are defined with \passthrough{\lstinline!impl!} blocks
in Rust. There can be many such blocks for a certain type.
Implementation blocks either just add methods on a type or they
\emph{implement a trait}, that is they provide implementations for all
the methods specified by the trait for a given type,
\passthrough{\lstinline!impl TraitX for TypeA!}. The blocks may be
generic i.e.~add methods to all instantiations of a polymorphic type
(example \passthrough{\lstinline!Option<T>!}) or they may be specific to
a certain instantiation (\passthrough{\lstinline!List<i32>!}).

\begin{lstlisting}[language=Rust, caption={Rust trait with two implementations.}]
trait Equals {
  fn equals(&self, x: &Self) -> bool;
  fn not_equals(&self, x: &Self) -> bool { !self.equals(x) }
}
impl Equals for i32 {
  fn equals(&self, y: &i32) -> bool { *self == *y }
}
impl<T: Equals> Equals for List<T> {
  fn equals(&self, other: &List<T>) -> bool { ... }
}
// A regular method on the List type.
impl<T> List<T> {
  #[measure(self)]
  pub fn size(&self) -> u32 { ... }
}
\end{lstlisting}

The Rust compiler automatically and implicitly resolves which method to
call for any given receiver in the code. If no suitable implementation
is in scope, it signals an error. A similar but nonetheless different
mechanism is achieved in Scala by means of type classes. In regular
Scala, the resolution of type class methods and instances is done
through the \emph{implicits mechanism} of Scala. In Stainless, this
resolution has to be done manually, but it remains possible to translate
the Rust semantics of traits and implementations to Stainless by means
of type classes.

\begin{lstlisting}[
  language=Scala,
  caption={Type class with implementations in Scala.},
  label=lst:equals-scala
]
abstract class Equals[T] {
  def equals(x: T, y: T): Boolean
  def notEquals(x: T, y: T): Boolean = !this.equals(x, y)
}
case object i32asEquals extends Equals[Int] {
  def equals(x: Int, y: Int): Boolean = x == y
}
// The argument for this class has to be manually provided.
case class ListasEquals[T](ev0: Equals[T]) extends Equals[List[T]] {
  def equals(x: List[T], y: List[T]): Boolean = ??? // will call `ev0.equals`
}
\end{lstlisting}

The largest addition, other than mutability, of this thesis project is
support for the features just described: implementation blocks and
traits with implementations by means of type classes. Rust-Stainless not
only extracts type classes and objects from Rust traits, but it also
infers which type class instance to call at each method call site.
Moreover, one can specify contracts on traits and methods. Whether they
live in an implementation block or are abstract trait items, methods can
state all the specification attributes like regular functions (as an
example take the post attributes on \passthrough{\lstinline!width!} and
\passthrough{\lstinline!height!} of \autoref{lst:liskov1}).
Additionally, one can attach \emph{laws} to traits i.e.~algebraic
properties on type classes that ensure that implementors hold the
contract set by the type class \cite[section "Specifying Algebraic
Properties"]{stainless-doc}. Stainless proves correctness of these laws
for each implementation of the trait. \autoref{lst:liskov1} shows an
exemplary violation of the Liskov Substitution principle \cite{liskov}.

\begin{lstlisting}[language=Rust, caption={Example trait with laws.}, label={lst:liskov1}]
trait Rectangle {
  #[post(ret > 0)]
  fn width(&self) -> u32;
  #[post(ret > 0)]
  fn height(&self) -> u32;

  fn set_width(&self, width: u32) -> Self;
  fn set_height(&self, height: u32) -> Self;

  #[law]
  fn preserve_height(&self, any: u32) -> bool {
    self.set_width(any).height() == self.height()
  }
  #[law]
  fn preserve_width(&self, any: u32) -> bool {
    self.set_height(any).width() == self.width()
  }
}
\end{lstlisting}

The trait defines four methods and states with two laws that a change to
the width should not change the height and vice versa. Clearly, the
following implementation of a rectangle holds these properties.

\begin{lstlisting}[language=Rust, caption={Example implementation of the trait.}]
struct Rect { width: u32, height: u32 }
impl Rectangle for Rect {
  fn width(&self) -> u32 { self.width }
  fn height(&self) -> u32 { self.height }
  fn set_width(&self, width: u32) -> Self {
    Rect { width, height: self.height }
  }
  fn set_height(&self, height: u32) -> Self {
    Rect { width: self.width, height }
  }
}
\end{lstlisting}

Without the laws, it would be tempting to add a square implementation.
However, that implementation changes both dimensions at once --
violating the laws. Stainless detects this, the square implementation
fails verification, and thereby the violation is caught.

\begin{lstlisting}[language=Rust, caption={Example implementation violating the laws.}]
struct Square { width: u32 }
impl Rectangle for Square {
  fn width(&self) -> u32 { self.width }
  fn height(&self) -> u32 { self.width }
  fn set_width(&self, width: u32) -> Self {
    Square { width }
  }
  fn set_height(&self, height: u32) -> Self {
    Square { width: height }
  }
}
\end{lstlisting}

Polymorphic type parameters can be bounded in Rust by trait bounds. For example,
\lstinline!T: Equals! in \autoref{lst:poly-bound} states that any \lstinline!T!
admissible to the function (in other cases the implementation block) needs to
implement the \passthrough{\lstinline!trait Equals!},
i.e.~\lstinline!impl Equals for T! needs to be available. This pattern
corresponds to the \emph{evidence parameter} pattern in Scala, with which the
caller proves that the instantiated type satisfies the given constraint.
Rust-Stainless is capable of extracting such trait bounds from top-level
functions, trait implementations, and regular implementation blocks. It
translates them to evidence arguments in Scala as shows \autoref{lst:ev-params2}.

\begin{lstlisting}[
  language=Rust,
  caption={Polymorphic function with a trait bound.},
  label=lst:poly-bound
]
#[post(ret > 0)]
pub fn fn_with_bound_and_spec<T: Equals>(x: &T, y: &T) -> i32 {
  if x.eq(y) { 123 } else { 456 }
}
\end{lstlisting}

\begin{lstlisting}[
  language=Scala,
  caption={Translation of the trait bound as evidence parameter.},
  label=lst:ev-params2
]
def fn_with_bound_and_spec(x: T, y: T, ev0: Equals[T]): Int = {
  if (ev0.eq(x, y)) 123 else 456
} ensures { _ > 0}
\end{lstlisting}

\begin{quote}
\TODO{What about the fixes on the Stainless side?}
\end{quote}



\subsection{Implementation details}

\subsubsection{Extraction overview}
\label{sec:extraction-overview}

As we have seen in \autoref{sec:pipeline}, the big majority of the work
performed by Rust-Stainless happens in the extraction of the HIR to
Stainless AST. We can now take a more detailed look at the most
interesting phase of our tool. The phase is implemented in the
\passthrough{\lstinline!stainless\_extraction!} crate and the
entry-point is the function \passthrough{\lstinline!extract\_crate!},
which -- as discussed -- processes the single current crate for which
\passthrough{\lstinline!rustc!} provides the HIR.

Before dealing with the user code in the crate, the extraction needs to
register some specially treated items that we call \emph{standard
items.} These are Rust language features like panic, standard library
items like \passthrough{\lstinline!Box<T>!} and
\passthrough{\lstinline!Option<T>!}, but also all types and methods of
\passthrough{\lstinline!libstainless!} like
\passthrough{\lstinline!Set<T>!} and \passthrough{\lstinline!get\_or!}.
Extraction needs to know the identifiers (the
\passthrough{\lstinline!DefId!}s) of those items in order to recognise
them in user code and trigger their specialised extraction procedures.
Initially, we only know the \emph{paths} of the items to detect e.g.
\passthrough{\lstinline!stainless::Set::new!} but that does not suffice
because \passthrough{\lstinline!rustc!} does not have an API to query
items from other crates \emph{by path} at the time of writing. All the
lookups are done by \passthrough{\lstinline!DefId!}. Therefore, the
implementation has to enumerate all \passthrough{\lstinline!DefId!}s
from the \passthrough{\lstinline!std!} and
\passthrough{\lstinline!stainless!} crate, compare them by name to the
desired items and register them if needed. This approach is clearly a
brute-force work-around around the lack of by-path lookups in
\passthrough{\lstinline!rustc!} but as the number of crates to take into
consideration is fixed and low, the lookup time is constant and
extraction time is still low.

With standard item detection done, the tool can now turn to user code.
The main procedure of extraction enumerates all top-level
items\footnote{\url{https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/hir/enum.ItemKind.html}}
of the crate like functions, structs, enums and traits. For enums and
structs, the phase directly proceeds and translates the HIR definition
to a Stainless ADT definition. Because enumeration order is undefined,
all the top-level methods of the extraction follow the same idea:
\passthrough{\lstinline!get\_or\_extract!}. That is, the first time an
item is visited, it is extracted and its definition is stored in state,
then on subsequent encounters the definition is simply retrieved.

For functions, the extraction distinguishes between external, abstract
and local functions but not between methods and functions because in the
HIR the two are the same (with the first parameter of methods being the
receiver). External and abstract functions are only extracted from the
HIR as they only have a signature. For local functions, we query the
body expression in THIR form from the compiler and extract it with the
\passthrough{\lstinline!expr!} module. The
\passthrough{\lstinline!extract\_expr!} method of that module takes a
\passthrough{\lstinline!thir::Expr!} and returns a
\passthrough{\lstinline!st::Expr!}, hence it is the entry-point of the
actual translation.

\subsubsection{Synthesisation}

Multiple translations that Rust-Stainless performs rely on the ability
to synthesise expressions of certain ADT types that do not necessarily
occur in user code. For example for the Stainless map, we construct
options (\passthrough{\lstinline!Some(v)!}), in other locations mutable
cells and tuples e.g.~\passthrough{\lstinline!Tuple3(x, y, z)!}.
Moreover, the fields of these ADTs also need to be available:
\passthrough{\lstinline!tuple.\_0!} and
\passthrough{\lstinline!cell.value!}.

In implementing synthesisation, we observe a primary benefit of the
\passthrough{\lstinline!get\_or\_extract!} pattern. For example, when
some translation needs the option type, it triggers its synthesisation.
But all synthesisation methods internally implement a
\passthrough{\lstinline!get\_or\_create!} logic, i.e.~if the option type
has already been either extracted from user code or synthesised by a
former synthesisation call, it is simply reused and the demanded ADT
expression can be built with its identifier. That way, we only
synthesise ADT definitions on demand and we never run the risk of
extracting one definition of option and synthesising a second one. The
latter also shows why it is crucial to register and recognise standard
items.

\subsubsection{Type Class Extraction}

Type class extraction introduces a distinction between regular
\passthrough{\lstinline!impl!} blocks for which we simply extract the
methods as top-level functions, and
\passthrough{\lstinline!impl TraitX for TypeA!} blocks that need to be
extracted as type class implementations, i.e.~\emph{case classes} or
\emph{case objects}. Of course, traits are extracted as \emph{abstract
classes}.

Internally, Rust represents
\passthrough{\lstinline!impl TraitX for TypeA!} blocks with a
\emph{trait bound} on the block
i.e.~\passthrough{\lstinline!Self: TraitX!}, while Scala uses
inheritance (\passthrough{\lstinline!extends!}). Furthermore, Rust
traits are implemented on the implicit \passthrough{\lstinline!Self!}
type parameter, whereas Scala type classes always have at least one type
parameter representing the type for which the class is implemented.
Fortunately, \passthrough{\lstinline!rustc!} internally treats the
\passthrough{\lstinline!Self!} like a regular type parameter, therefore
it internally already has the Scala form. As \autoref{lst:clstranslation}
shows, the trait bounds on type parameters of implementations are
converted to evidence parameters. If an implementation has no type
parameter, it can be extracted as a ground case object.

\noindent
\begin{minipage}[t]{.49\textwidth}
\begin{lstlisting}[
  language=Rust,
  showlines=true,
  caption={Examples of traits and implementations with and without trait bounds.}
]
trait Equals { ... }

trait Other<X, Y> { ... }

impl Equals for i32 { ... }

impl<T: Equals> Equals for List<T>
  { ... }

\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.49\textwidth}
\begin{lstlisting}[
  language=Scala,
  caption={
    Translation as type classes (\lstinline!abstract!) and implementations.
    Trait bounds are translated as evidence parameters.},
  label={lst:clstranslation}
]
abstract class Equals[Self] { ... }

abstract class Other[Self, X, Y]
  { ... }
case object i32asEquals
  extends Equals[Int] { ... }
case class ListasEquals[T](
  ev0: Equals[T]
) extends Equals[List[T]] { ... }
\end{lstlisting}
\end{minipage}

If there are classes, it is also necessary to distinguish \emph{function
calls} from \emph{method calls}. This distinction is mostly achieved by
adding flags like \passthrough{\lstinline!abstract!} and
\passthrough{\lstinline!methodOf(i32asEquals)!} to methods. The
challenge of method calls is to resolve the receiver instance they are
called on. For example, \autoref{lst:equals-scala} shows a call to
\passthrough{\lstinline!this.equals!} inside the type class. In Rust,
this is implicitly resolved but because our type class instances are
only created in the extraction, the phase also has to resolve the
receiver instances itself.

Instance resolution takes a triple of class identifier, receiver type
and type parameters, as well as the current surrounding class to resolve
the receiver instance. For example, inside a type class, the
\passthrough{\lstinline!this!} instance is accessible, inside classes
with evidence parameters, the evidence instances are available and
ground case objects are always in scope. As a last resort, instance
resolution recursively checks whether it can create a new type class
instance by providing it the required evidence arguments. This happens
for example for \passthrough{\lstinline!List<i32>!}, which gets
translated to
\passthrough{\lstinline!ListasEquals[i32](i32asEquals).equals!} unless
we are in the implementation of the class itself.

\subsubsection{Spec Closure Encoding}

In \autoref{sec:pipeline} we already saw how our specification attributes
on functions are desugared by the procedural macro of
\passthrough{\lstinline!libstainless!} into an annotated closure nested
inside the function (\autoref{lst:example2}). The extraction phase
recognises the closures by their attribute and translates them to
Scala's \passthrough{\lstinline!require!},
\passthrough{\lstinline!ensures!} and
\passthrough{\lstinline!decreases!}. Stainless later checks on its own
that the specification does not have any effects.

The encoding with closures is the third spec encoding that we explored
and implemented. It unifies the advantages of the two previous designs
in that it works for \emph{all} kinds of functions, top-level,
implementation methods and abstract or default trait methods, and that
it can use type parameters of the original function. The first encoding
desugared closures to inner functions in the original one. This served
mainly to circumvent the borrow checker. The nested functions duplicated
the parameters of their parent. In that way, new bindings were created
without borrow interference with the actual parameters but with the same
types and identifiers -- simple to extract to
\passthrough{\lstinline!require!} and
\passthrough{\lstinline!ensuring!}. The problem with that encoding was
that it was neither able to use type parameters of the surrounding
function, nor could it use the \passthrough{\lstinline!self!} parameter
inside methods because neither are available to inner functions in Rust.
Therefore, the second encoding was created only for methods in
\passthrough{\lstinline!impl!} blocks. There, specs were desugared to
sibling functions with a special name such that they could declare the
\passthrough{\lstinline!self!} parameter. However, there were now two
different encodings in use simultaneously and even the sibling functions
fell short of accounting for spec attributes on methods in traits.

To support specs on trait implementation methods, we needed to come back
to a nested encoding because Rust does not allow additional items other
than the specified methods in trait implementations. Nested closures
would enable such an encoding and even allow to use surrounding type
parameters at the cost of not being able to use the
\passthrough{\lstinline!self!} parameter. Therefore, our encoding
replaces \passthrough{\lstinline!self!} with a
\passthrough{\lstinline!\_self: Self!} parameter on the closure which
extraction will again correlate with the correct receiver.

The last problem was that abstract trait methods do not have a body for
adding a closure. A simple solution is to add a body with the spec
closure and a panic to the method. Yet, that makes the method a default
method which prevents the compiler of enforcing its implementation by
all implementors -- something we did not want to sacrifice. We achieve
the best of both worlds with conditional compilation. The spec closures
are desugared with a \passthrough{\lstinline!cfg(stainless)!} attribute
that makes them vanish on normal compilation, hence the compiler
enforces implementation, but keeps them when the compiler is run with
the \passthrough{\lstinline!stainless!} flag which happens at
verification.



\section{Limitations}
\label{impl-limitations}

\subsection{Unsupported Rust features}

Language features not mentioned in \autoref{sec:supported-features} are not yet
supported. However, not all language features are of the same importance. Here,
we mention the ones that are required for our goal of verifying \emph{idiomatic}
Rust code. The two very important Rust features not yet supported are closures
and sequences. Besides that, we also don't support \emph{unsafe Rust}. This is a
conscious decision as many of our translations rely on the assumption that only
the \emph{safe} Rust is used. Further missing features that are less complex to
add are supertraits, i.e. type class inheritance in Scala, top-level constants,
and invariants on ADTs like in Stainless.

For closures, most of the infrastructure is already in place as closures
are represented very similarly to functions in the compiler.
Nonetheless, there are some difficulties. Closures can capture variables
from the surrounding scope, which includes moving variables from the
surrounding scope into the closure. This becomes very difficult to
manage for Stainless if these variables are mutable
\cite[section 3.4.3]{regb}. The second problem arises with higher-order
functions that take closures as parameters. In Rust, to take a closure
as an argument, the argument type is a type parameter with a trait bound
like \passthrough{\lstinline!F: Fn(i32) -> i32!}. This polymorphism is
harder to translate than directly specified lambda types like in Scala
\passthrough{\lstinline!Int => Int!}.

With sequences we mean vectors, arrays, iterators, but also loops. Implementing
loops and even arrays should be feasible as these are already supported in
Stainless \cite[section "Imperative"]{stainless-doc}. On the other hand,
iterators and vectors are very difficult to translate because they are not
inherent \emph{language} features but rather some of the most important but also
complex items of the standard library.

\paragraph{One Crate Limitation}

For standard library items we run into the limitation that is imposed by the
one-crate-a-time compilation model of \passthrough{\lstinline!rustc!}. Our tool
is currently not able to extract the code of standard library items because they
are not part of the user crate, hence no HIR is available. This is probably the
biggest technical limitation of Rust-Stainless' implementation. Various
approaches could be explored to solve it:

\begin{itemize}
\item
  If Rust-Stainless could read its serialised output and work with that,
  then the tool could translate a crate, serialise the representation
  and read it again when working on the next crate. For example, one
  could extract and translate the required crate from the standard
  library, serialise it and then import in when translating the user
  crate.

  The problem of that approach is that many of the widely used standard
  library items like vectors are implemented with very advanced features
  and \emph{unsafe Rust.} Extracting code of that level of complexity is
  clearly out of scope for a user-focused tool.
\item
  The contrary approach would be to provide completely synthetic
  definitions of standard items. That is, the tool would detect usage of
  items like a vector and then synthesise some definition and
  implementation like it does for the Stainless set and map.

  While this approach would be technically feasible with the current
  state of the software, it would be an unstable and labour-intensive
  endeavour because the synthetic shadow implementation would need to
  stay in sync with the standard library. Moreover, the standard library
  of Rust is large and the choice of what to provide would be difficult.
\item
  The most promising way of dealing with crate-external items is to let
  the user provide contracts to emulate the external items. Indeed, this
  is the approach other tools take \cite{prusti, mirai}. The given
  contracts will be interpreted as correct and used to verify the user
  code. Our library could also provide contracts for the most frequently
  used standard items, which is what \cite{mirai} does. Keeping such
  contracts up-to-date would still require less work than providing
  synthetic shadow implementations. The only disadvantage of this
  approach is that the user can still state false contracts for the
  external items, which leads to incorrect results.
\end{itemize}

\subsection{Stainless Backend Limitations}

\subsubsection{Type Classes}

Traits are omnipresent in Rust. For example, Rust does not have an
equality operation on all types by default like Scala. Rather,
comparison operators (in the language) are only defined on primitive
types and for other types, the \passthrough{\lstinline!==!} operator is
desugared to a call to the trait method
\passthrough{\lstinline!PartialEq::eq!} of the standard library. Most
types however provide a derived implementation of
\passthrough{\lstinline!PartialEq!} that performs structural comparison.

On one hand, this shows how important our translation of traits to type
classes is. On the other hand, this poses a problem for Stainless
because there, Scala-like structural equality exists on all types. To
deal with the trait methods, the frontend needs to extract the trait
implementations of \passthrough{\lstinline!PartialEq!} with its type
class mechanism. This either forces the user to provide an
implementation for equality that Stainless can understand, or it
requires the solution of the crate-external items problem, as discussed
in the previous section.

The second problem with type classes is that they are expensive in
verification with the current Stainless pipeline. Functions that rely on
type class instances are transformed by multiple phases of the Stainless
pipeline and especially the \emph{refinement lifting} phase in such a
way that verification becomes untraceable and the solver times out.

A radical solution to the problem is to erase and replace calls to
\passthrough{\lstinline!PartialEq::eq!} by \passthrough{\lstinline!==!}
in the translation. With a similar safety check and argument as for the
erasure of \passthrough{\lstinline!Clone!} to
\passthrough{\lstinline!freshCopy!}, we can argue that only derived
instances of \passthrough{\lstinline!PartialEq!} can be safely replaced
by the structural \passthrough{\lstinline!==!} operator of Scala.

\subsubsection{Mutability}

In \autoref{sec:aliasing-restrictions} we have tailored our general
translation around the specific aliasing restrictions of the Stainless
backend. This can already be seen as a limitation because it renders the
translation more complex. If we had a Scala verifier for the entire
Scala language, we could simply use the general translation.
Nonetheless, thanks to Rust's borrow checking guarantees, the
translation can be adapted rather well to the restrictions but some
limitations remain.

The \emph{imperative phase} of Stainless is not the most stable part of the
pipeline and is also still under active development. Rust-Stainless targeted the
phase as a new frontend in ways that were unforeseen and therefore, many bugs
were discovered. Most of them have already been solved, like incorrect constant
propagation. For code using mutability in complex ways like the
\autoref{lst:mut-ref-12}, it is still possible to find new bugs in the backend.
This particular example fails because of a incorrect effect target
calculation.\footnote{\url{https://github.com/epfl-lara/stainless/issues/1111}}

As discussed in the previous section, the refinement lifting phase makes
examples using type classes more expensive to verify. In combination with the
mutable tuple and cell encoding this unfortunately leads to two larger
benchmarks of the test suite timing
out.\footnote{\url{https://github.com/epfl-lara/stainless/issues/1093}} Luckily,
the refinement lifting phase is set to be removed from the pipeline in the
future which may solve these issues.

\paragraph{Other approaches}

To overcome the limitations of Stainless' current imperative phase, a
new \emph{full imperative} phase using a \emph{heap encoding} has been
proposed \cite{new-imperative}. That new phase has explicit support for
mutable references \passthrough{\lstinline!AnyHeapRef!} which represent
parts of the heap. Furthermore, it uses annotations on functions that
state which references are read (\passthrough{\lstinline!reads!}) and
which are written to (\passthrough{\lstinline!modifies!}) by the
function. These two features are very promising to target from
Rust-Stainless because they resemble things that are already in our
mutability translation. The mutable references are very close to our
mutable cells and it might even be possible to infer the information
needed for the read and write annotations from the mutability of the
function parameters, which is explicitly stated in Rust.

A radically different approach for dealing with mutability would be to
extract the Rust program not from the THIR but from the lower-level MIR.
We discuss this approach in the next section.

\subsection{Design Limitations}

The current way of translating the THIR to Stainless ASTs has many
advantages. The THIR is very close to Stainless ASTs and errors,
counter-examples or insights coming from Stainless are easily mapped
back and forth between the two representations. On the downside, the
THIR still has many features that all need to be understood by our
translation, which can render the latter more complex. More importantly,
the THIR does not have any information about liveness, reference
lifetimes, and borrowing because all these analyses are only performed
later on the MIR. This is the fundamental limitation of translating from
the THIR.

The advantage of the MIR is that the representation is even more
explicit, there are less features to translate, and lifetimes have been
resolved. That means, it would be possible to manually propagate changes
back to borrowed variables at the lifetime end of mutable borrows. On
the other hand, the MIR is in CFG form and it should be challenging to
transform that graph form back to a syntax tree. It is also unfeasible
to combine the THIR and the MIR because they do not use the same
identifiers for variables.
