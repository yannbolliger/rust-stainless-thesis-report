Although Rust introduces many features and ideas from functional programming
into systems programming, it still is a language for high performance and
low-level programming. Therefore, idiomatic Rust makes heavy use of mutability.
To reduce rewriting Rust code before verifying it with our frontend, we
therefore need to support mutability in Rust-Stainless. In this chapter, we
introduce a translation of Rust's owned types and references into Scala that is
equivalent in runtime semantics. After providing some background on the type
system of Rust, we will argue that the translation is correct and then encounter
some optimisations and usability results that make it possible to use the
translation together with the current state of the Stainless verifier backend.


\section{Background}
We start by introducing some programming language and compiler concepts that
will be needed to gather the subtleties of our translation. Some of the concepts
are general and apply  to many languages, nonetheless we present all of them in
the context of Rust and its compiler.

\subsection{Liveness}

\emph{Liveness} is a general concept in programming languages and can be
determined by a \emph{data-flow analysis}. In Rust, the concept is particularly
important because it is central to the analysis of borrow checking. As liveness
applies to variables, we first need to know the defintion of variables in
Rust:

\begin{quote}
A variable is a component of a stack frame, either a named function parameter,
an anonymous temporary, or a named local variable. \cite[section
"Variables"]{rustref}
\end{quote}

A variable is said to be \emph{live} if it holds a value that may be used at any
future point of the program \cite{wiki:live-vars}. Otherwise, that variable is
said to be \emph{dead}. This is for example the case if the variable is
reassigned before the next read. The part of the program in which a variable is
live is called its \emph{lifetime}. The same applies to references in Rust, a
reference is live if it will be used at any a future point of all possible
execution paths.

Fields are not considered variables in Rust, rather they are a part of the
variable their corresponding struct is bound to. Hence, fields inherit the
liveness of their struct's variable unless they are themselves bound to a local
variable e.g. via a pattern match.



\subsection{Value Categories}

In programming languages that expose memory management to the programmer
like C and Rust, one needs to distinguish between different \emph{value
categories} of a variable:

\begin{itemize}
\tightlist
\item
  \emph{lvalues} are expressions that designate memory locations, for
  example variables, array elements etc. They are objects that have a
  storage address. The term originates from the fact that lvalues are on
  the left-hand side of an assignment.
\item
  \emph{rvalues} are expressions or temporary values that do not
  persist. They are on the right-hand side of an assignment \cite{wiki:lvalues}.
\end{itemize}

These two terms have been used in Rust but were replaced by \emph{place
expressions} and \emph{value expressions}. Value expressions represent actual
values and are defined by exclusion from place expressions. Place expressions
evaluate to a \emph{place} which is essentially a memory
location~\cite{rustref}.

\begin{quote}
{[}Place{]} expressions are paths which refer to local variables,
{[}\ldots{]} dereferences (\passthrough{\lstinline!*expr!}), array
indexing expressions (\passthrough{\lstinline!expr[expr]!}), field
references (\passthrough{\lstinline!expr.f!}) {[}\ldots{]}. \\
\cite[section "Expressions"]{rustref}
\end{quote}

Place expressions occur in \emph{place expression contexts} like on the
left-hand side of let-bindings, as borrow operands, as field expression
operands or as pattern match scrutinees. Otherwise, if a place
expression is evaluated in a \emph{value context,} e.g.~on the
right-hand side of a binding, it evaluates to what is stored at the
place it evaluates to. We say, its data is \emph{used}.

\subsection{Mutability}

In Rust, mutability is declared at binding-time of new names, not at the
definition of data types. That means an object of some type can be
mutable or immutable depending on its binding
(e.g.~\passthrough{\lstinline!let!} or
\passthrough{\lstinline!let mut!}) but independently of the object's
type. Mutable variables, mutable references, fields of mutable variables
etc. are called \emph{mutable place expressions} and only they can be
used in \emph{mutable place expression contexts} like the left-hand side
of assignments and as operands of mutable borrows. The consequence is
that any field of any struct in Rust is \emph{possibly} mutable
depending on the binding of that instance.

\subsection{Owning and Referencing Data}

\subsubsection{Ownership}

Rust's most distinguishing feature is that it is memory-safe without
need for a garbage collector. That is achieved by its novel approach to
\emph{data ownership} which is partly inspired by \emph{linear ownership
types} \citep{ownership-types} but goes much further.

The core principle of the ownership system is that \textbf{data is owned
by exactly one binding}. If some data is later used in an assignment or
passed to a function, it will be \emph{moved out} of that binding. The
binding is deinitialised and can never be reused, we say it behaves
linearly \cite{oxide}. One can also see moving out as \emph{destructive
read} \cite{islands-alias-protection} where the binding is dead after the read.
In \RefCode{lst:move},
data is moved out of \passthrough{\lstinline!a!} and its
ownership is transferred to \passthrough{\lstinline!b!}.

\begin{lstlisting}[
  language=Rust,
  label=lst:move,
  caption={A struct type with move semantics.}
]
struct A { a: i32 };
let a = A { a: 123 };
let b = a;
// `a` can never be used from here
\end{lstlisting}

One departure from these almost \emph{use once} \citep{use-once} variables are
copyable types. Types that implement the \passthrough{\lstinline!Copy!} trait in
Rust get copy semantics rather than move semantics. The compiler automatically
implements this for primitive types (numeric types cf. \RefCode{lst:copy},
\passthrough{\lstinline!char!}, \passthrough{\lstinline!bool!}) but also shared
references and tuples of copyable types \cite[section "Special
types and traits"]{rustref}. When data of these types is used, it's implicitly
copied and the original binding and data stay valid and independent.

\begin{lstlisting}[
  language=Rust,
  label=lst:copy,
  caption={Copy semantics of the \lstinline!i32! type.}
]
let a = 123;
let mut b = a;
b += 1;
// `a` can still be used and is == 123
\end{lstlisting}

For types that are not copyable, we are still able to explicitly create
copies of objects by implementing the \passthrough{\lstinline!Clone!}
trait and calling the \passthrough{\lstinline!Clone::clone!} method.

\subsubsection{References}

Reading and even writing data that one does not own is still possible in
Rust but has to be done with references. References are created by
\emph{borrowing} with the \passthrough{\lstinline!\&!} operator. One can
either borrow from owned data directly or one can \emph{reborrow} from
an existing reference. When passing a reference to an object as a
function argument, we say we pass that argument \emph{by reference,} as
opposed to passing the entire object \emph{by value} and hence moving or
copying it.

Rust's type system and borrow checking guarantee that all references are
always valid (e.g.~no use-after free is possible). This is possible
under a very strict set of rules. At any point in the program and for
any data there can either exist

\begin{itemize}
\tightlist
\item
  multiple immutable i.e.~\emph{shared references}
  \passthrough{\lstinline!\&T!} that may read the referenced data,
\item
  or there can be a \emph{unique mutable reference}
  \passthrough{\lstinline!\&mut T!} that is allowed to read and write
  to the data it does not own.
\end{itemize}

During the lifetime of a shared reference, the data can be read but not
changed by the owning binding. In contrast, the mutable reference allows
to change data without owning it under the condition that there exist no
other references to that data. While the mutable reference is live, even
the owning binding is neither allowed to read nor to write that place.

These rules underpin how Rust can ensure memory safety at compile time
and therefore form the core of the language. The type and borrow checker
of the Rust compiler enforce the rules or in the words of \citet{oxide}:

\begin{quote}
{[...]} we understand Rust's borrow checking system as ultimately being a system
for statically building a proof that data in memory is either
\emph{uniquely owned} (and thus able to allow unguarded mutation) or
\emph{collectively shared}, but not both.
\end{quote}

\subsection{Rust Compared to Scala}

\subsubsection{Mutability}

In Scala, there are local mutable variables
(\passthrough{\lstinline!var!}) comparable to
\passthrough{\lstinline!let mut!} in Rust. Class fields however are
immutable by default. At the class declaration one can opt into
mutability for a certain field by marking it as
\passthrough{\lstinline!var!}. That field is then mutable on all
instances of the class and irrespective of whether an instance is
locally bound with the immutable \passthrough{\lstinline!val!} or the
mutable \passthrough{\lstinline!var!}.

\subsubsection{References}

Places or lvalues are not programatically accessible in Scala, as in JVM
languages there is no way to take a reference to a place explicitly.
That means it's impossible to generalise over whether one wants to
assign to a local variable or an object field by taking a reference and
assigning to the dereference.

As in all JVM languages, objects in Scala are heap-allocated and
function parameters are always passed by value. However, for objects
this value is just a reference to the object in the heap. This is very
efficient for sharing immutable objects but retaining by-value
semantics. But as a consequence, the by value passing of references
closely resembles by reference passing if an object is mutable. The
translation presented in \RefChapter{translation} will extensively exploit this fact.



All of the following underlies the assumption that the input Rust code
is \emph{safe} and ``well-behaved''. That is we consider the
\emph{safe subset} \cite[section "Unsafety"]{rustref}
of the 2018 edition of Rust and we assume single-threaded
execution. In particular, our translation requires the absence of
\emph{interior mutability} \cite[section "Interior Mutability"]{rustref}
of types, that is all types are immutable through shared
references. This can be enforced by prohibiting the use of \emph{smart
pointers} like the ones from \passthrough{\lstinline!std::cell!}.
Moreover, the safe subset of Rust excludes features like raw pointers,
\passthrough{\lstinline!union!}, unsafe functions and blocks, as well as
external, like linked C-code. In practice, all unsafe features are
detected at extraction of the code and abort the translation.

\section{Translation}

\subsection{General Translation}

The goal of our translation is to bridge the gaps between Rust's and
Scala's memory model -- making places accessible in the program and
allowing mutability of possibly all fields of structs. To achieve the
first one and bring the ability of manipulating references to Scala, we
introduce a special wrapper ADT, the mutable cell:

\begin{lstlisting}[language=Scala, style=short]
case class MutCell[T](var value: t)
\end{lstlisting}

The mutable cell object is used as a layer of indirection on all Scala
values and directly models the \emph{place} of the value, where the
value is stored in the field (\passthrough{\lstinline!value!}). Note
that the field is mutable, which in principle allows changes to any
place. We will see that after after the translation, the mutable cell's
field will be the only mutable variable in the program. All mutability
in the original Rust program will be modelled with that field.

\begin{quote}
Whenever something is mutable, we wrap it into a mutable cell.
\end{quote}

All local variables are wrapped into a mutable cell, regardless of their
mutability in Rust. The wrapping enables taking references to local
variables which is needed for both mutable and immutable variables. This
approach also enables us to create references to data of primitive types
like integers, something that is impossible directly in Scala.

Likewise, all ADT and tuple fields are mutable cells with the type of
the original field as the type argument of the cell. Thereby, we achieve
our second goal from above -- all fields are \emph{possibly} mutable.

\begin{lstlisting}[language=Rust, caption=Some example Rust code.]
struct A<T> { a: T, b: i32 }
let x = A { a: "foo", b: 123 }
let mut y = 123
assert!(y == x.b)
\end{lstlisting}

\begin{lstlisting}[
  language=Scala,
  caption=The potentially mutable fields of the struct are modelled with mutable
  cells and both let bindings are wrapped into cells as well.
]
case class A[T](a: MutCell[T], b: MutCell[Int])
val x = MutCell(A(MutCell("foo"), MutCell(123)))
val y = MutCell(123)
assert(y.value == x.value.b.value)
\end{lstlisting}

We can see that every place in the Rust program is modelled by the
introduction of a mutable cell object. Hence, all place expressions in
the original program correspond to exactly one mutable cell instance in
the translation.

\subsubsection{Tuples}

Tuples in Rust are simply anonymous tuple structs. As for all structs
their mutability is decided at binding time, contrary to Scala, where
tuples are always immutable. To allow for tuple mutation in Rust, we
translate Rust's tuples to case classes of the following form for any
positive arity. The empty tuple is the Unit.

\begin{lstlisting}[language=Scala, style=short]
case class Tuple2[T0, T1](_0: MutCell[T0], _1: MutCell[T1])
\end{lstlisting}

\subsubsection{Accessing}

If a field or a variable is read, the translation introduces an access
to the \passthrough{\lstinline!value!} field of the corresponding cell.
The same happens for dereferencing. In other words, any place expression
that is evaluated in a value context is translated as reading the
\passthrough{\lstinline!value!} of the corresponding mutable cell
object. Thus, we see how the translation unifies the access of locally
available bindings and references that may come from elsewhere.

\paragraph{Copy vs moving}

When place expressions are used in value contexts their data is used, i.e.~moved
or copied. We will later argue that the translation is correct as-is for
moveable types. However, for copyable types, we need to ensure that the new copy
is distinct from the original in the translation as well.

This holds trivially for primitive JVM types as they are copied by value
on the JVM as well. The same goes for shared Rust references, where the
reference is copied but still points to the same object. Because the
reference is shared, the designated object must be immutable, hence
sharing is the same as copying.

Tuples of copyable types, for example tuples of numbers, are copyable as
well in Rust which is a problem for the translation. If we just used
sharing of tuple objects in the translation, the following example would
be incorrect:

\begin{lstlisting}[language=Rust, caption=The tuple is copied on line 2.]
let x = (123, false);
let mut y = x; // copies `x`
y.0 = 456;
assert!(x.0 == 123) // correct
\end{lstlisting}

\begin{lstlisting}[
  language=Scala,
  label=lst:tuple-sharing,
  caption=In Scala the tuple object is shared not copied.
]
val x = MutCell(Tuple2(MutCell(123), MutCell(false)))
val y = MutCell(x.value) // shares tuple object
y.value._0.value = 456   // i.e. x.value == y.value
assert(x.value._0.value == 123) // fails
\end{lstlisting}

To avoid such problems, we introduce two operators in the translation:
\passthrough{\lstinline!move[T](t: T): T!} and
\passthrough{\lstinline!copy[T](t: T): T!}. They can be thought of as
top-level functions that perform a deep copy of their argument. An
implementation for these operators could be based on type classes for
example, but we'll not go into more implementation details of the
operators here. Now, whenever data is directly accessed, the translation
wraps the field access of the cell \passthrough{\lstinline!value!} into
one of the two operators, depending on the type of the data. For example
in the last snippet on line two, the right-hand side of the assignment
becomes \lstinline!MutCell(copy(x.value))!.(For primitive
types, this can be omitted as an optimisation because primitive types
are also copied by value on the JVM.)

Types that the programmer marks with
\passthrough{\lstinline!\#[derive(Copy)]!} , i.e.~user-defined type that
are copyable run into the same issue as tuples but we will ignore these
for the moment as the current state of our extraction implementation
does not yet accept such types. Nonetheless, the solution would be to
use the \passthrough{\lstinline!copy!} operator as well.

\subsubsection{Referencing}

A borrow creates a reference to a place in Rust and makes that reference
available as a value in the program e.g.~it can be bound to a name.
After translation the place expression in Rust is equivalent to the JVM
reference of the cell object. Hence, passing around Rust references as
values can be translated to passing around cell objects as field values
of other cells in Scala. (Passing around the cells conveniently happens
by reference on the JVM.)

As an example, if a Rust reference is stored in a local variable, this
creates two nested cells in the Scala translation. The outer cell models
the local variable and the value of its field holds the other cell which
models the Rust reference.

\noindent\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[language=Rust]
let x: T = ...;
let r = &mut x;
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[language=Scala]
val x = MutCell[T](...)
val r = MutCell(x)
\end{lstlisting}
\end{minipage}

\subsubsection{\texorpdfstring{\textbf{Matching}}{Matching}}

For pattern matching the same principles apply as for evaluating place
expressions. If a match happens on an rvalue, the Scala match will be on
the \passthrough{\lstinline!value!} field of that cell. If the scrutinee
is a reference, then the Scala scrutinee is the mutable cell.

The patterns are adapted to include the mutable cell wrappers of fields.
Depending on whether a resulting binding of a match is a reference or
not in Rust, the Scala pattern matches the cell or only its field.

\noindent\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[
  language=Rust,
  caption={In the first case, \lstinline!a! binds the value of \lstinline!x.a!
  whereas in the other cases it is \lstinline!&mut x.a!.}
]
match x {
    A { a, .. } => ...
}
match &mut x {
  A { a, .. } => ...
}
match x {
  A { mut ref a, .. } => ...
}
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[
  language=Scala,
  caption={In the first case, \lstinline!a! matches the field \lstinline!value!
    of the cell, whereas in the other cases it matches the cell object.}
]
x.value match {
    case A(MutCell(a), _) => ...
}
x match {
    case MutRef(A(a, _)) => ...
}
x.value match {
    case A(a, _) => ...
}
\end{lstlisting}
\end{minipage}

\subsubsection{Assigning}

Mutating values in both Rust and Scala is done by assigning new rvalues
to lvalues. The translation for assignments is analogous to the one for
accessing places and again unifies local variables and references. If a
place expression is assigned an rvalue, the translation assigns to the
\passthrough{\lstinline!value!} field of the cell, no matter whether the
place expression is a local variable or a mutable reference.

\noindent\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[language=Rust]
let x: &mut i32 = ...
*x = 123;
let mut y = 456;
y = 789;
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[language=Scala]
val x: MutCell[Int] = ???
x.value = 123
val y = MutCell(456)
y.value = 789
\end{lstlisting}
\end{minipage}

\subsubsection{Function parameters}

Rust functions can take parameters by reference or by value. This is modelled in
the translation by wrapping the parameter in a mutable cell or directly passing
it ``by value'' -- in the JVM sense.

Additionally, it is possible to declare the parameter binding as mutable
by marking it \passthrough{\lstinline!mut!}. This is equivalent to a
mutable local variable and not visible outside of the function. To model
that local mutability we again wrap the parameter in a mutable cell. We
do this regardless of whether the parameter is locally mutable to keep
the invariant that each place i.e.~each variable corresponds to one
cell. At function call site, we wrap all arguments into newly created
cells to ensure that local mutations on these parameters remain local to
the callee.

\begin{lstlisting}[
  language=Rust,
  caption={\lstinline!i! is only mutable inside the function.}
]
let r = 123;
fn f(mut i: i32, x: &i32) { ... }
f(456, &r);
\end{lstlisting}

\begin{lstlisting}[language=Scala]
val r = MutCell(r)
def f(i: MutCell[Int], x: MutCell[MutCell[Int]]) = ???
f(MutCell(456), MutCell(r))
\end{lstlisting}

\subsubsection{Boxes}

Contrary to the JVM, where all objects live on the heap, Rust lets the
programmer choose whether to allocate objects on the stack or the heap.
Heap allocation is achieved with the \passthrough{\lstinline!Box<T>!}
type. Everything, that is put into a box instance, goes to the heap
\passthrough{\lstinline!Box::new(A \{ ... \})!}, everything else is
allocated on the stack.

As the fact whether something is on the heap or the stack does not
matter to verification as long as general memory safety is preserved, we
erase this distinction in the translation and just use normal
heap-allocated Scala objects.

\subsection{Correctness}
\label{correctness-claim}

\begin{quote}
Under the assumption that the original Rust program type \& borrow
checks, we argue that the described translation of mutable Rust
references and owned types to mutable cells in Scala is equivalent in
runtime semantics, i.e.~when run the Scala translation yields the same
result as the Rust program.
\end{quote}

First, we have to clarify the strong but powerful assumption. The Rust
borrow checker ensures that there is no unsafely aliased state,
i.e.~aliased state that is mutated, in the original program. It may seem
that this is an unnecessarily strict assumption for our translation.
But, Rust's ownership system is so fundamental to the language that it
is impossible to define Rust's semantics without borrow checking
\cite{krust}. Consider the \RefCode{lst:move-err}. Because
\passthrough{\lstinline!y!} moves out \passthrough{\lstinline!x!} on
line 3, \passthrough{\lstinline!x!} can never be reused and it is not
defined what \passthrough{\lstinline!x!} would evaluate to if the code
ran despite violating that rule. Therefore, the borrow check assumption
is necessary to be able to reason about the semantics of the original
program.

\begin{lstlisting}[
  language=Rust,
  label=lst:move-err,
  caption={This code does not compile due to the use after move in line 5.}
]
struct A { a: i32 };
let x = A { a: 123 };
let mut y = x;  // `x` is moved to `y`
y.a = 456;
assert!(x.a == 123) // ERROR, can't reuse `x`
\end{lstlisting}

Let us now observe that the translation introduces a bijection between
Rust places and mutable cells. As seen before, places can be variables,
struct/tuple fields or array elements. The translation wraps each local
variable, each function parameter and each field into a mutable cell,
hence each of these places corresponds to exactly one cell except for
arrays which are not supported yet.

Secondly, we observe that the translation unifies the access to values
by dereferencing and by directly mentioning a local variable. Both are
done through the cell object's field after translation. Hence, one can
say the translation lifts everything into references; even local
variables are accessed through that single gateway to the value that the
cell object is. Furthermore, the cell's field is the only location where
program data can reside. Thus, we recognise Rust's principle that data
is always owned uniquely (by a cell) and otherwise referenced (through
the cell).

More formally, we examine the three ways in which data can be accessed
in Rust to argue that our translation results in correct Scala runtime
semantics.

\subsubsection{By value}
\label{sec:correctness-by-value}

If data is \emph{used} by value in Rust, it transfers ownership to the
new binding/owner. This holds for both moved types and copied types.
Only for the latter, the original owner as well as its data stay intact,
whereas for moved types, the original owner is invalidated and the data
deinitialised. In both cases, if the used data is later mutated, changes
will not appear on the original data or owner. Therefore, our
translation is correct to insert the \passthrough{\lstinline!move!} or
\passthrough{\lstinline!copy!} operator -- which for this argument we
can think of as deep copies -- around by value reads of a cell's
\passthrough{\lstinline!value!}.

Performing a deep copy for moved types is correct because the original
binding is never reused. Thus, we can think of moving as performing a
deep copy of the original object, assigning it to a new owner and then
destroying the original object. The importance is that changes made to
the moved object never propagate back to the original.

For types marked with the \passthrough{\lstinline!Copy!} trait we
distinguish between aggregate types and primitive types. Primitive types
like numbers and booleans are handled the same by Rust and the JVM and
need no further examination. Aggregate types like tuples of numbers are
translated to Scala objects with mutable cells as fields. Therefore, we
have to argue that the deep object copy our
\passthrough{\lstinline!copy!} operator performs is equivalent to the
implicit bitwise copy of the struct in Rust.

Indeed, bitwise copy for an aggregate type is trivially the same as deep
copy as long as all contained types are present by value. That means all
contained data is embedded in the bits of the aggregate structure and
hence copied deeply as well. It gets more complicated for shared
references (mutable references are not copyable as they need to be
unique). For a shared reference, Rust simply copies the reference,
i.e.~the pointer value, but not the referenced object. Still, that
operation is equivalent to a deep copy because the references must be
shared references. Hence, by the borrow check assumption, as long as any
shared reference to some object exists, that object cannot be mutated.
In other words, a shared reference will never see its referenced value
change. Therefore, it is equivalent to copy that object deeply when
needed, the sharing is simply an optimisation performed by Rust.

The above holds for tuples, arrays and user-defined
\passthrough{\lstinline!Copy!} types as long as our
\passthrough{\lstinline!copy!} operator supports them in Scala. Other
copyable types like raw pointers and function pointers are not supported
by the translation nor our extraction implementation.

\subsubsection{By reference}

The counterpart of \emph{using} data and transferring its ownership is
to take references to places. Our translation does that by using the
place's cell object which is defined and unique, as we saw earlier. With
the cells it becomes possible and simple to reference places on the JVM;
it suffices to mention i.e.~to use the correct cell whenever we need to
refer to a place. As cells are objects, we can simply use them in a
by-value manner and reference handling is done by the JVM. Hence,
references are achieved through object sharing on the JVM.

In particular, when a cell is used in multiple locations it will not be
cloned but all the locations will point to the same cell object. This
exactly corresponds to the semantics of shared Rust references that we
model with the cells and is thus correct.

For mutable references, the mechanism is entirely the same, we share the
cell object to emulate a reference. Any changes made on the cell's value
will be later visible to all readers. This sounds dangerous because we
should never mutate shared data. But thanks to the borrow check
assumption, we know that no illegal sharing or aliasing can occur. The
borrow checker has made sure that for example all shared references to
an object end their lifetime \emph{before} the object is mutated. In the
translation, such a shared reference might still exist somewhere on the
JVM before the garbage collector passes, but it will never be read or
used thanks to the borrow checker. Hence, the translation is correct for
mutable references as well.





\section{Implementation}

The translation presented so far results in correct Scala runtime semantics, but
the motivation behind the translation was to ultimately use it to verify the
Scala program with the Stainless verifier. Intuitively, we submit the translated
program to Stainless, get a verification result and deduce verification
properties for the Rust program from that. The approach is correct because both
programs exhibit the same runtime semantics, as we have shown. However,
Stainless does not support the entire Scala language. In particular, it has some
limitations concerning mutability. Therefore, we adapt the general translation
step-by-step to yield Scala programs that are accepted by Stainless.

This section presents the changes made to the translation to reach compatibility
with Stainless on a coarse-grained theoretical level. Like before, we will show
that all the deviations from the general translation uphold the overall
correctness. For more low-level implementation details and an overview of the
entire system please refer to \RefChapter{implementation}.




\subsection{Translation without Aliasing}
\label{sec:aliasing-restrictions}

The main difference between Scala and the supported imperative fragment of
Stainless \cite[section "Imperative"]{stainless-doc} is that Stainless imposes
aliasing restrictions on the program. The restrictions enable a simple but
strict aliasing invariant:

\begin{quote}
{[}For{]} each object in the system, each path of pointers reaches a
distinct area of the heap. \cite[p.~59]{regb}
\end{quote}

Concretely, the following restrictions apply to mutable types, i.e. types that
may contain \lstinline!var! fields or type parameters marked with
\lstinline!@mutable!:

\begin{itemize}
\tightlist
\item
  For a function call, no mutable arguments of the call can share any
  part of their memory. E.g. in a function call it is not allowed to
  give an object as one argument and a field of the same object as
  another argument.
\item
  More generally, ``it is forbidden to assign a mutable variable to a
  new identifier'' \cite[p.~59]{regb}.
\item
  And lastly, ``a function cannot return an object that shares memory
  locations with one of its parameters'' \cite[p.~59]{regb}.
\end{itemize}

As our translation uses mutable cells everywhere, virtually all
resulting types are mutable and fall under these restrictions. On the
other hand, the motivation of Stainless' aliasing restrictions is to
make its imperative code elimination phase work \cite{regb}. The
transformation relies on the fact, that there is only a single path to a
mutable object, so changes to the object are correctly detected when the
path is used. However, the restrictions are quite severe and there are
plenty of cases where an alias is safe but is not allowed by these
rules.\footnote{For example, when there are shared references i.e.~aliases of a
mutable object but that object is never changed.}

In our case, Rust's borrow checker ensures a very similar property:
there is a \emph{unique} mutable reference to an object or otherwise it
is safe to have multiple shared (immutable) references. By relying on
the borrow check assumption, we know that the translated program does
not have illegal aliasing of mutable state, but we need to convince
Stainless of that fact. We achieve this again with our deep copy
operators \passthrough{\lstinline!move!} and
\passthrough{\lstinline!copy!}.

The translation already introduces \passthrough{\lstinline!move!} and
\passthrough{\lstinline!copy!} when data is used by value, e.g.~in
assignments and for function arguments. To work around Stainless'
aliasing restrictions we additionally introduce
\passthrough{\lstinline!copy!} for function arguments that are shared
references and lastly, we \passthrough{\lstinline!move!} or
\passthrough{\lstinline!copy!} return values of functions and inner
blocks, unless they contain mutable references. The correctness of that
approach follows from the same argument as the correctness of using
\passthrough{\lstinline!move!} on moveable types and
\passthrough{\lstinline!copy!} on copyable types (see \RefSec{sec:correctness-by-value}).

To summarise, all types are \passthrough{\lstinline!move!}'d or
\passthrough{\lstinline!copy!}'d when they could create an alias except
types that are or contain mutable references, for which the borrow
checker has made sure they are not aliased. Hence, the resulting program
contains no aliasing of mutable types but still preserves correct
runtime semantics.

\subsubsection{move is the identity}

Here, we show that our \passthrough{\lstinline!move!} operator --
though very useful to work with Stainless -- is not necessary to the
semantical correctness of the translation and may be omitted by implementations
that do not need to comply with Stainless' aliasing restrictions.

\begin{quote}
Under the assumption that the original Rust program type \& borrow
checks, the \passthrough{\lstinline!move!} operator is semantically
equivalent to the identity and simply serves as a method to make
verification work with a simple aliasing analysis.
\end{quote}

As we have seen before, we can think of moving as performing a deep copy and
invalidating the original. By making the copy in a move, we avoid creating an
alias to the source cell in the translation. But because the borrow checker
guarantees that a moved out value is never used again, this unintentional alias
will never be used and hence, does not matter for the correctness of the
program. Recall \RefCode{lst:move-err} on line 3, the struct is moved out of
\passthrough{\lstinline!x!} into \passthrough{\lstinline!y!}, that is without
the \passthrough{\lstinline!move!} call an alias of
\passthrough{\lstinline!x!}'s cell would be created. But the binding from
\passthrough{\lstinline!x!} will never be used again, hence this alias is safe
and the inserted \passthrough{\lstinline!move!} only serves to communicate this
fact to the simple aliasing analysis of Stainless. The same holds for function
arguments and return values. Thus, in order to only achieve correct Scala
runtime semantics, the \passthrough{\lstinline!move!} is not needed and can be
omitted because it is equivalent to the identity.

\subsubsection{\texorpdfstring{\texttt{copy} is the functional
identity}{copy is the functional identity}}

The second claim only concerns completely functional programs, that is
programs that do not mutate any data.

\begin{quote}
Under the assumption that the original Rust program type \& borrow
checks and in the absence of \emph{all mutation}, the
\passthrough{\lstinline!copy!} operator is semantically equivalent to
the identity and simply serves as a method to make verification work
with a simple aliasing analysis.
\end{quote}

Consider \RefCode{lst:tuple-sharing}, the introduced sharing
i.e.~aliasing of the tuple object is fixed by adding the
\passthrough{\lstinline!copy!} operator. But the aliasing only poses a
problem because the tuple is later modified. If the tuple wasn't
modified, sharing it would be safe and the program correct.

More generally, in the absence of mutation, there are only shared
references and immutable by value bindings. For the latter, if data
needs to be copied according to Rust semantics but is immutable, then it
is safe to share the objects in the translation because the data cannot
be changed at any time. The same holds for shared references. We
remember that a shared reference can never see its referenced data
change, therefore it is safe to deeply copy the referenced object. But
again, if that data cannot change at all due to the absence of mutation,
we may as well share the objects. We conclude that the
\passthrough{\lstinline!copy!} operator is equivalent to the identity in
programs with no mutation.

\subsubsection{Cloning is copying}
\label{sec:clone-is-copy}

Unlike the built-in implicit copy that occurs for Rust types marked with
the \passthrough{\lstinline!Copy!} trait, a clone always happens
explicitly by calling \passthrough{\lstinline!Clone::clone!}.
Programmers can define their own implementation of the
\passthrough{\lstinline!Clone!} trait or they can let a macro derive an
instance.

\begin{quote}
Under the assumption that all \passthrough{\lstinline!Clone!} instances
in a program are derived, calling \passthrough{\lstinline!clone!} is
equivalent to performing a deep copy. Thus,
\passthrough{\lstinline!clone!} is correctly translated with the
\passthrough{\lstinline!copy!} operator.
\end{quote}

Derived \passthrough{\lstinline!Clone!} instances for aggregate types like
structs recursively call \passthrough{\lstinline!clone!} on all the fields and
return a new struct with the cloned fields. For copyable types, especially
primitive types, the clone is trivially a bitwise copy like for
\lstinline!Copy!.\footnote{\url{https://doc.rust-lang.org/std/clone/trait.Clone.html}}
For shared references, we have already shown (see
\RefSec{sec:correctness-by-value}) that copying them is equivalent to a deep
copy of the referenced object. By a simple inductive argument, if all the
field's \passthrough{\lstinline!Clone!} instances are equivalent to deep copies,
then the struct's instance is equivalent to a deep copy as well. Hence, as long
as all component types recursively are copyable types or have derived
\passthrough{\lstinline!Clone!} instances, the top-level instance is equivalent
to a deep copy.

In the translation, we can therefore check that assumption and if it
holds, we translate calls to \passthrough{\lstinline!Clone::clone!} with
our \passthrough{\lstinline!copy!} operator that is the identity in
completely functional programs or performs a deep copy otherwise.




\subsection{Optimisations}

Even if the translation presented here serves to add mutability features to
Rust-Stainless, we would like to preserve the well-functioning parts of the
frontend that deal with functional, immutable Rust code. To that end, the
implemented translation contains certain optimisations to the general
translation that increase the usability of Rust-Stainless for functional Rust
code.


\subsubsection{Immutable Bindings and References}

The most important optimisation in the implementation is that immutable bindings
(local variables, function parameters) are not wrapped in mutable cells.
Morever, shared references i.e. immutable references are erased, like boxes, and
the values/data of the underlying binding is used directly.

It is possible to perform that optimisation thanks to excellent compiler support
of the Rust compiler, that provides type information for all expressions. With
that, it is  possible to distinguish immutable values and shared references at
all times from  possibly mutable ones that need to be wrapped in cells.

To convince ourselves of the correctness of this optimisation, we first note
that only mutable data can be borrowed mutably. In other words, only for mutable
data do we need the reference sharing in the translation to propagate changes
back to the original binding. For immutable data, there are no changes in the
first place. Secondly, it is safe to directly use actual immutable values
instead of references, even if the values get copied at some points, as we have
already shown in \RefSec{sec:correctness-by-value}. Therefore, it is correct to
erase shared references and use their referred value directly.

\subsubsection{Preventing Aliasing}

We have already seen how our two theoretical operators \lstinline!move! and
\lstinline!copy! are used to emit code that complies with Stainless' aliasing
restrictions (\RefSec{sec:aliasing-restrictions}). We have also argued that
\lstinline!copy! \emph{must} perform a semantical deep copy, while
\lstinline!move! \emph{may} do a deep copy but might also be the identity. For
our Stainless-backed implementation, we use a special Stainless primitive to
implement both operators: \lstinline!freshCopy[T](t: T): T!, performs a
semantical deep copy of its argument. Because our implementation only serves to
verify Rust code, it does not matter that we deep copy data that is not strictly
required to be copied.

With that, the extraction implementation decides at all places of the code where
data is used by value whether to insert a \lstinline!freshCopy! based on the
data's type. Types that are mutable references or that contain mutable
references, like \lstinline!Option<&mut T>!, are not \lstinline!freshCopy!'d.
Otherwise, we omit the copy for types that are primitive types in both Rust and
on the JVM: booleans, numbers, unit, characters, and panics/\lstinline!Nothing!.
Additionally, we don't insert \lstinline!freshCopy! around some control
structures for which we know by design that a \lstinline!freshCopy! will be
inserted inside the structure, for example for \lstinline!match!, we know that
the resulting value of each arm will be copied and therefore don't need to copy
the entire match expression.

For cloning, the same procedure is applied. conveniently, the Rust compiler does
not derive \lstinline!Clone! instances for types that are or contain mutable
references.\footnote{\href{}{\texttt{\color{MidnightBlue}
https://doc.rust-lang.org/std/clone/trait.Clone.html\#impl-Clone-121 }}}
Therefore, it is sufficient to check our assumption from
\RefSec{sec:clone-is-copy} to make sure that all types for which clone is
translated will get a \lstinline!freshCopy! inserted.

To summarise, we deeply copy some of the moves to prevent aliasing in the
resulting code. But, we never copy mutable references because for them, the Rust
compiler has made sure that there are no aliases. Lastly, we do the same for
cloning because we made sure that only clone operations are extracted for which
these semantics are correct.




\subsubsection{Nested Mutable Cells}




\subsection{Functional Fragment / Usability}

Functional/immutable programs make use of sharing. For functional Rust
programs it may be necessary to \passthrough{\lstinline!Clone::clone!}
data to emulate sharing \& have the full expressiveness of functional
programming.

\begin{itemize}
\tightlist
\item
  Purity detection by fn\_signature
\end{itemize}

\textbf{Claim}

\begin{itemize}
\tightlist
\item
  Functional Rust programs get translated to functional Stainless trees
  despite the presence of some mutability features like mutable cells in
  all ADTs
\end{itemize}

This is a fragment that Stainless supports well.
